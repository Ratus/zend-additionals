<?php
namespace ZendAdditionals\Db\Mapper;

use ZendAdditionals\Db\Adapter\MasterSlaveAdapterInterface;
use ZendAdditionals\Db\Entity\AbstractDbEntity;
use ZendAdditionals\Db\EntityAssociation\EntityAssociation;
use ZendAdditionals\Db\Mapper\AttributeProperty;
use ZendAdditionals\Db\Mapper\Exception;
use ZendAdditionals\Db\ResultSet\JoinedHydratingResultSet;
use ZendAdditionals\Stdlib\Hydrator\ClassMethods;
use ZendAdditionals\Stdlib\Hydrator\ObservableClassMethods;
use ZendAdditionals\Stdlib\Hydrator\Strategy\ObservableStrategyInterface;
use ZendAdditionals\Stdlib\StringUtils;
use ZendAdditionals\Stdlib\ArrayUtils;

use Zend\Db\Adapter\Adapter;
use Zend\Db\Adapter\Driver\ResultInterface;
use Zend\Db\Adapter\Exception\InvalidQueryException;
use Zend\Db\Adapter\AdapterAwareInterface;
use Zend\Db\Sql\AbstractSql;
use Zend\Db\Sql\Expression;
use Zend\Db\Sql\Delete;
use Zend\Db\Sql\Predicate;
use Zend\Db\Sql\Predicate\Operator;
use Zend\Db\Sql\Select;
use Zend\Db\Sql\Sql;
use Zend\Db\Sql\Update;
use Zend\EventManager\EventManager;
use Zend\EventManager\EventManagerInterface;
use Zend\ServiceManager\Exception\ServiceNotFoundException;
use Zend\ServiceManager\ServiceManager;
use Zend\ServiceManager\ServiceManagerAwareInterface;
use Zend\Stdlib\Hydrator\HydratorInterface;

/**
 * @category    ZendAdditionals
 * @package     Db
 * @subpackage  Mapper
 */
abstract class AbstractMapper implements
    ServiceManagerAwareInterface,
    AdapterAwareInterface
{
    const SERVICE_NAME           = '';

    const RELATION_TYPE_FOREIGN  = 'foreign';
    const RELATION_TYPE_MY       = 'my';
    const RELATION_TYPE_VALUE    = 'value';
    const RELATION_TYPE_CALLBACK = 'callback';

    const OPERAND_EQUALS         = Operator::OPERATOR_EQUAL_TO;
    const OPERAND_NOT_EQUALS     = Operator::OPERATOR_NOT_EQUAL_TO;
    const OPERAND_IN             = 'in';
    const OPERAND_LESS           = Operator::OPERATOR_LESS_THAN;
    const OPERAND_LESS_OR_EQUALS = Operator::OPERATOR_LESS_THAN_OR_EQUAL_TO;
    const OPERAND_MORE           = Operator::OPERATOR_GREATER_THAN;
    const OPERAND_MORE_OR_EQUALS = Operator::OPERATOR_GREATER_THAN_OR_EQUAL_TO;

    const EVENT_FLUSH_RUNTIME_RESULT_CACHE = 'abstractmapper.flush.runtime.result.cache';

    /**
     * @var Adapter
     */
    protected $dbAdapter;

    /**
     * @var Adapter
     */
    protected $dbSlaveAdapter;

    /**
     * @var ObservableClassMethods
     */
    protected $hydrator;

    /**
     * @var object
     */
    protected $entityPrototype;

    /**
     * @var Select
     */
    protected $selectPrototype;

    /**
     * @var Sql
     */
    private $sql;

    /**
     * @var Sql
     */
    private $slaveSql;

    /**
     * @var string
     */
    protected $tableName;

    /**
     * @var string
     */
    protected $originalTableName;

    /**
     * @var boolean
     */
    private $isInitialized = false;

    /**
     * array containing arrays of keys that are combined to primary keys
     * @var type
     */
    protected $primaries = array();

    /**
     * Identifier of a column that gets an auto generated value,
     * only one is possible'
     *
     * @var string
     */
    protected $autoGenerated;

    /**
     * @var ServiceManager
     */
    protected $serviceManager;

    /**
     * @var array
     */
    protected $relations = array();

    /**
     * @var \SplObjectStorage
     */
    protected $entityAssociationStorage;

    /**
     * @var array
     */
    protected $extraJoinRequiredKeys        = array('operand', 'left', 'right');

    /**
     * @var array
     */
    protected $extraJoinColumnRequiredKeys  = array('value', 'type');

    /**
     * @var EventManagerInterface
     */
    protected static $eventManager;

    /**
     * @var boolean
     */
    protected $tablePrefixRequired = false;

    /**
     * @var array
     */
    protected $relationsByServiceName = array();

    /**
     * @var array
     */
    protected $attributeRelations = array();

    /**
     * @var array
     */
    protected $attributeRelationsGenerated = false;

    /**
     * Xml attribute columns tells which of the columns
     * holds xml and what fields are available within the xml
     *
     * @var array
     */
    protected $xmlAttributeColumns        = array();

    /**
     * Serialized attribute columns tells which of the columns
     * holds serialized data, the column identifier must be the key
     * with all possible fields being the values. An empty array tells
     * to use all the values.
     *
     * @var array
     */
    protected $serializedAttributeColumns = array();

    /**
     * Boolean indicating if debug events are enabled or not
     *
     * @var boolean
     */
    protected $debugEventsEnabled = false;

    /**
     * The last errors that has been occured during query execution
     *
     * @var Collection\Error
     */
    protected $lastErrors;

    /**
     * Keep track if we're in a transaction or not
     *
     * @var boolean
     */
    protected static $transactionStarted        = false;

    /**
     * Keeps track if the save is running
     *
     * @var boolean
     */
    protected $saveRunning = false;

    /**
     * Flag for moderation requirements
     *
     * @var boolean
     */
    protected static $moderationMode = false;

    /**
     * Constructor
     */
    public function __construct()
    {
        if (static::$eventManager === null) {
            $this->setEventManager(new EventManager());
        }

        // Attach to his own event
        $this->getEventManager()->attach(
            self::EVENT_FLUSH_RUNTIME_RESULT_CACHE,
            function() {
                $this->getHydrator()->resetObjectStorage();
            }
        );
    }

    /**
     * Flush all the mappers
     */
    public function flushRuntimeCache()
    {
       $this->getEventManager()->trigger(
            self::EVENT_FLUSH_RUNTIME_RESULT_CACHE,
            $this
       );
    }

    /**
     * Check if this mapper allows filtering be implemented.
     *
     * @return boolean
     */
    protected function getAllowFilters()
    {
        return true;
    }

    public function getAttributeTablePrefix()
    {
        return $this->attributeRelations['table_prefix'];
    }

    /**
     * @param array $xmlAttributeColumns
     *
     * @return AbstractMapper
     */
    public function setXmlAttributeColumns(array $xmlAttributeColumns)
    {
        $this->xmlAttributeColumns = $xmlAttributeColumns;
        return $this;
    }

    /**
     * @return array
     */
    public function getXmlAttributeColumns()
    {
        return $this->xmlAttributeColumns;
    }

    /**
     * @param array $serializedAttributeColumns
     *
     * @return AbstractMapper
     */
    public function setSerializedAttributeColumns(array $serializedAttributeColumns)
    {
        $this->serializedAttributeColumns = $serializedAttributeColumns;
        return $this;
    }

    /**
     * @return array
     */
    public function getSerializedAttributeColumns()
    {
        return $this->serializedAttributeColumns;
    }

    /**
     * Set the event manager
     *
     * @param EventManagerInterface $eventManager
     *
     * @return AbstractMapper
     */
    public function setEventManager(EventManagerInterface $eventManager)
    {
        static::$eventManager = $eventManager;
        return $this;
    }

    /**
     * Enable or disable debug events
     *
     * @param boolean $boolean
     *
     * @return AbstractMapper
     */
    public function setDebugEventsEnabled($boolean)
    {
        $this->debugEventsEnabled = (boolean) $boolean;
        return $this;
    }

    /**
     * Are the debug events enabled?
     *
     * @return boolean
     */
    public function getDebugEventsEnabled()
    {
        return $this->debugEventsEnabled;
    }

    /**
     * @return EventManagerInterface
     */
    public function getEventManager()
    {
        return static::$eventManager;
    }

    public function count(array $filter = null, array $joins = null)
    {
        // Copy the filter to avoid messing with referenced objects inside
        $filter = ArrayUtils::deepClone($filter);

        $select = $this->getSelect();

        // Filter attribute joins when filter requires it
        if (is_array($filter)) {
            foreach ($filter as $possibleAttribute => $operator) {
                if (
                    isset($this->attributeRelations['attributes']) &&
                    array_search($possibleAttribute, $this->attributeRelations['attributes']) !== false
                ) {
                    $attributeMapper = $this->getServiceManager()->get(Attribute::SERVICE_NAME);
                    /*@var $attributeMapper Attribute*/
                    $attribute = $attributeMapper->getAttributeByLabel($possibleAttribute, $this->attributeRelations['table_prefix']);
                    $attributeFilter = null;

                    $setIdentifier = 'setIdentifier';
                    $setValue = 'setValue';
                    $getValue = 'getValue';
                    $operatorClone = clone $operator;
                    if (method_exists($operatorClone, 'getLeft')) {
                        $setIdentifier = 'setLeft';
                        $setValue = 'setRight';
                        $getValue = 'getRight';
                    }

                    $multiple = false;
                    if (method_exists($operatorClone, 'getValueSet')) {
                        $multiple = true;
                        $getValue = 'getValueSet';
                        $setValue = 'setValueSet';
                    }

                    if ($attribute->getType() === 'enum') {
                        $attributePropertyMapper = $this->getServiceManager()->get(AttributeProperty::SERVICE_NAME);
                        /*@var $attributePropertyMapper AttributeProperty*/
                        $newOperatorValue = false;
                        if ($multiple) {
                            $newOperatorValue = $attributePropertyMapper->getPropertyIdsByAttributeIdAndLabels($attribute->getId(), $operatorClone->$getValue(), $this->attributeRelations['table_prefix']);
                        } else {
                            $newOperatorValue = $attributePropertyMapper->getPropertyIdByAttributeIdAndLabel($attribute->getId(), $operatorClone->$getValue(), $this->attributeRelations['table_prefix']);
                        }

                        if (!$newOperatorValue) {
                            return;
                        }

                        $operatorClone->$setIdentifier('attribute_property_id');

                        $operatorClone->$setValue($newOperatorValue);
                        $attributeFilter = array(
                            'attribute_property_id' => $operatorClone
                        );
                    } else {
                        $operatorClone->$setIdentifier('value');
                        $attributeFilter = array(
                            'value' => $operatorClone
                        );
                    }

                    $this->addAttributeJoin($select, $possibleAttribute, false, $attributeFilter);
                    unset($filter[$possibleAttribute]);
                }
            }
        }

        /*
         * When surfing through joins and going a level deeper a reference to
         * the current depth gets appended to this array to be able to go
         * back when the nested array has been looped.
         */
        $pointer       = &$joins;
        $joinDepth     = array();
        $ref           = null;
        $filterPointer = &$filter;
        while(true && is_array($joins)) {
            $var = each($pointer);
            if ($var === false) {
                if (empty($joinDepth)) {
                    // There is no previous array to jump back to
                    break;
                }
                // Restore current pointer to the previous depth
                $previous      = array_pop($joinDepth);
                $pointer       = &$previous[0];
                $ref           = $previous[1];
                $filterPointer = &$previous[2];

                // When previous round a filterPointer has been created. Unset
                // the record. Otherwise it will be added to the wheres
                if (
                    array_key_exists($previous[3], $filterPointer) &&
                    empty($filterPointer[$previous[3]])
                ) {
                    unset($filterPointer[$previous[3]]);
                }
                continue;
            }
            /*
             * When the value is an array we want add a join based on the key,
             * store a reference to this join and set the pointer to this array
             * to start the nested loop.
             */
            if (is_array($var['value'])) {
                $joinDepth[] = array(
                    &$pointer,
                    $ref,
                    &$filterPointer,
                    $var['key']
                );

                // Only join when we have some filters for the join
                if (isset($filterPointer[$var['key']])) {
                    $ref = $this->addJoin(
                        $select,
                        $var['key'],
                        $ref,
                        array(), // no need for columnsfilter
                        (isset($filterPointer[$var['key']]) ?
                            $filterPointer[$var['key']] :
                            null
                        )
                    );
                }

                /*@var $ref EntityAssociation*/
                $pointer = &$pointer[$var['key']];
                if (
                    is_array($filterPointer) &&
                    isset($filterPointer[$var['key']])
                ) {
                    $filterPointer = &$filterPointer[$var['key']];
                } else {
                    $filterPointer[$var['key']] = array();
                    $filterPointer = &$filterPointer[$var['key']];
                }
                continue;
            }
            // Only join when we have some filters for the join
            if (isset($filterPointer[$var['value']])) {
                $this->addJoin(
                    $select,
                    $var['value'],
                    $ref,
                    array(),
                    (isset($filterPointer[$var['value']]) ?
                        $filterPointer[$var['value']] :
                        null
                    )
                );
            }
        }

        $where = new \Zend\Db\Sql\Where();
        $applyWhereFilter = false;
        if (is_array($filter)) {
            foreach ($filter as $key => $operator) {
                if (is_array($operator)) { //Skip join conditions
                    continue;
                }

                if (!($operator instanceof Predicate\PredicateInterface)) {
                    $value    = $operator;
                    $operator = new Operator();
                    $operator->setLeft($key)->setRight($value);
                }

                /**
                 * Flat operators to prepend aliases
                 */
                $flattenOperators = function($operator, array &$operators, $me) {
                    if (($operator instanceof Predicate\PredicateSet) === false) {
                        $operators[] = $operator;
                        return;
                    }

                    $operatorsArray = $operator->getPredicates();

                    foreach ($operatorsArray as $operatorArray) {
                        $me($operatorArray[1], $operators, $me);
                    }
                };

                // Flatten operators
                $operators = array();
                $flattenOperators($operator, $operators, $flattenOperators);

                foreach ($operators as &$item) {
                    $getIdentifier = 'getLeft';
                    $setIdentifier = 'setLeft';
                    if (method_exists($item, 'getIdentifier')) {
                        $getIdentifier = 'getIdentifier';
                        $setIdentifier = 'setIdentifier';
                    }
                    $currentIdentifier = $item->$getIdentifier();
                    if (strpos($currentIdentifier, '.') === false) {
                        $item->$setIdentifier(
                            $this->getTableName() . '.' . $currentIdentifier
                        );
                    }
                }

                $where->addPredicate($operator);
                $applyWhereFilter = true;
            }
        }

        // Apply filter
        if ($applyWhereFilter) {
            $select->where($where);
        }

        return $this->getCount($select);
    }

    /**
     * Fetch a single entity from the database this method is a shortcut
     * for the search method and requires less parameters plus adds some
     * extra checks to make sure one or no entity gets returned.
     *
     * @param array   $filter  array('column' => 'value', 'join1' => array('column' => 'value'))
     * @param array   $groupBy array('some_entity', 'other_entity', 'base_entity' => array('some_other_from_base'))
     * @param array   $joins   array('some_entity', 'other_entity', 'base_entity' => array('some_other_from_base'))
     * @param array   $columnsFilter array('col_one', 'some_entity' => array('col_two'))
     * @param boolean $returnEntities By default return entities, set to false for an array
     *
     * @return array|object|boolean false when nothing found
     *
     * @throws Exception\GetFailedException
     */
    protected function get(
        array $filter        = null,
        array $groupBy       = null,
        array $joins         = null,
        array $columnsFilter = null,
        $returnEntities      = true
    ) {
        try {
            $result = $this->search(
                null,
                $filter,
                null,
                $groupBy,
                $joins,
                $columnsFilter,
                $returnEntities
            );

            if (!is_array($result)) {
                throw new Exception\UnexpectedValueException(
                    'Did not expect anything else then array!'
                );
            }

            if (sizeof($result) > 1) {
                throw new Exception\UnexpectedValueException(
                    'More then one result found based on current filter!'
                );
            }

        } catch (\Exception $exception) {
            throw new Exception\GetFailedException(
                'Could not search, search failed!',
                0,
                $exception
            );
        }

        return (
            empty($result) ?
            false :
            $result[0]
        );
    }

    /**
     * Simple sum query
     *
     * @param array $fields         array('column', 'column2')
     * @param array $where          array('column' => 'value',)
     * @param object|NULL $entity   When object is given this object will hydrated with the value
     *                              Otherwise an array will be returned
     * @return object|array
     */
    protected function sum($fields, $where = array(), $entity = null)
    {
        // initialize where with select
        $select = $this->getSelect()->where($where);

        // Build columns filter.
        $columns = array();
        foreach ($fields as $field) {
            $columns[$field] = new Expression("SUM({$field})");
        }
        $select->columns($columns);

        // Fetch the results
        $result = $this->getCurrent($select, false);

        // Return array when no object has been given
        if (is_object($entity) === false) {
            return $result;
        }

        // Hydrate the results
        $hydrator = new ClassMethods();
        $hydrator->hydrate($result, $entity);

        return $entity;
    }

    /**
     * Search for entities for given time
     *
     * @throws event search_and_wait_next_iteration For every next internal search
     * this event gets thrown giving the ability to modify filters before the next
     * search.
     *
     * @param integer $timeout      The amount of seconds to search
     * @param integer $cooldown     Cooldownperiod between search queries (in microseconds)
     * @param array   $range array('begin' => 0, 'end' => 10)
     * @param array   $filter array('column' => 'value', 'join1' => array('column' => 'value'))
     * @param array   $orderBy array('column' => 'ASC', 'join2' => array('column' => 'DESC'))
     * @param array   $groupBy array('column', 'join2' => array('column'))
     * @param array   $joins array('some_entity', 'other_entity', 'base_entity' => array('some_other_from_base'))
     * @param array   $columnsFilter array('col_one', 'some_entity' => array('col_two'))
     * @param boolean $returnEntities By default return entities, set to false for an array
     *
     * @return array|boolean    Return array on any response | FALSE on timeout
     */
    public function searchAndWait(
        $timeout,
        $cooldown            = 500,
        array $range         = null,
        array $filter        = null,
        array $orderBy       = null,
        array $groupBy       = null,
        array $joins         = null,
        array $columnsFilter = null,
        $returnEntities      = true
    ) {
        $start       = microtime(true);
        $timeleft    = true;
        $firstSearch = true;

        while($timeleft) {
            if (!$firstSearch) {
                $responseCollection = $this->getEventManager()->trigger(
                    'search_and_wait_next_iteration',
                    $this,
                    array(
                        'filter' => &$filter,
                    )
                );
                $lastResponse = $responseCollection->last();
                if (
                    is_array($lastResponse) &&
                    array_key_exists('continue', $lastResponse) &&
                    false === $lastResponse['continue']
                ) {
                    // Last response told us to stop iterating!
                    $timeleft = false;
                    break;
                }
            }

            $results = $this->search(
                $range,
                $filter,
                $orderBy,
                $groupBy,
                $joins,
                $columnsFilter,
                $returnEntities
            );

            $firstSearch = false;

            // Results found return
            if (empty($results) === false) {
                break;
            }

            // Sleep to unstress CPU
            usleep($cooldown);

            $timeleft = (bool) ((microtime(true) - $start) < $timeout);
        }

        if ($timeleft === false) {
            return false;
        }

        return $results;
    }

    /**
     * Search entities within the database, the result is an array of entities
     * found or an empty array.
     *
     * @param array   $range array('begin' => 0, 'end' => 10)
     * @param array   $filter array('column' => 'value', 'join1' => array('column' => 'value'))
     * @param array   $orderBy array('column' => 'ASC', 'join2' => array('column' => 'DESC'))
     * @param array   $groupBy array('column', 'join2' => array('column'))
     * @param array   $joins array('some_entity', 'other_entity', 'base_entity' => array('some_other_from_base'))
     * @param array   $columnsFilter array('col_one', 'some_entity' => array('col_two'))
     * @param boolean $returnEntities By default return entities, set to false for an array
     *
     * @return array
     */
    protected function search(
        array $range         = null,
        array $filter        = null,
        array $orderBy       = null,
        array $groupBy       = null,
        array $joins         = null,
        array $columnsFilter = null,
        $returnEntities      = true,
        $return              = true
    ) {
        // Copy the filter to avoid messing with referenced objects inside
        $filter = ArrayUtils::deepClone($filter);
        $limit  = 1000;
        $offset = 0;

        if (isset($range['begin']) && $range['begin'] >= 0) {
            $offset = (int)$range['begin'];
        }

        if (isset($range['end']) && $range['end'] > $offset) {
            $limit = ((int)$range['end'] - $offset);
        }

        $select = $this->getSelect();
        $select->limit($limit);
        $select->offset($offset);

        $applyColumnsFilter = false;
        if (!empty($columnsFilter)) {
            $applyColumnsFilter = true;
        }
        $possibleXmlAttributeColumns        = $this->getXmlAttributeColumns();
        $possibleSerializedAttributeColumns = $this->getSerializedAttributeColumns();

        $xmlAttributes        = array();
        $serializedAttributes = array();

        $columns     = array();
        $joinColumns = array();
        if ($applyColumnsFilter) {
            foreach ($columnsFilter as $joinKey => $column) {
                if (is_array($column)) {
                    if (array_key_exists($joinKey, $possibleXmlAttributeColumns)) {
                        $columns[] = $joinKey;
                        if (!$returnEntities) {
                            $xmlAttributes[$joinKey] = (
                                empty($column) ?
                                $possibleXmlAttributeColumns[$joinKey] :
                                $column
                            );
                        }
                    } elseif (array_key_exists($joinKey, $possibleSerializedAttributeColumns)) {
                        $columns[] = $joinKey;
                        if (!$returnEntities) {
                            $serializedAttributes[$joinKey] = (
                                empty($column) ?
                                $possibleSerializedAttributeColumns[$joinKey] :
                                $column
                            );
                        }
                    } else {
                        $joinColumns[$joinKey] = $column;
                    }
                } else {
                    if (
                        !$returnEntities &&
                        array_key_exists($column, $possibleXmlAttributeColumns)
                    ) {
                        $xmlAttributes[$column] = $possibleXmlAttributeColumns[$column];
                    } elseif (
                        !$returnEntities &&
                        array_key_exists($column, $possibleSerializedAttributeColumns)
                    ) {
                        $serializedAttributes[$column] = $possibleSerializedAttributeColumns[$column];
                    }
                    $columns[] = $column;
                }
            }
        } else {
            foreach ($possibleXmlAttributeColumns as $column => $possibleXmlAttributes) {
                $xmlAttributes[$column] = $possibleXmlAttributes;
            }
            foreach ($possibleSerializedAttributeColumns as $column => $possibleSerializedAttributes) {
                $serializedAttributes[$column] = $possibleSerializedAttributes;
            }
        }

        if (
            isset($this->attributeRelations['attributes']) &&
            is_array($this->attributeRelations['attributes'])
        ) {
            foreach ($this->attributeRelations['attributes'] as $attributeIdentifier) {
                $attributeFilter = null;
                if (isset($filter[$attributeIdentifier])) {
                    $attributeMapper = $this->getServiceManager()->get(
                        Attribute::SERVICE_NAME
                    );
                    /*@var $attributeMapper Attribute*/
                    $attribute = $attributeMapper->getAttributeByLabel(
                        $attributeIdentifier,
                        $this->attributeRelations['table_prefix']
                    );

                    $setIdentifier = 'setIdentifier';
                    $setValue = 'setValue';
                    $getValue = 'getValue';
                    $operator = clone $filter[$attributeIdentifier];

                    if (method_exists($operator, 'getLeft')) {
                        $setIdentifier = 'setLeft';
                        $setValue = 'setRight';
                        $getValue = 'getRight';
                    }

                    $multiple = false;
                    if (method_exists($operator, 'getValueSet')) {
                        $multiple = true;
                        $getValue = 'getValueSet';
                        $setValue = 'setValueSet';
                    }

                    if ($attribute->getType() === 'enum') {
                        $attributePropertyMapper = $this->getServiceManager()
                        ->get(
                            AttributeProperty::SERVICE_NAME
                        );
                        /*@var $attributePropertyMapper AttributeProperty*/
                        $newOperatorValue = false;
                        if ($multiple) {
                            $newOperatorValue = $attributePropertyMapper
                            ->getPropertyIdsByAttributeIdAndLabels(
                                $attribute->getId(),
                                $operator->$getValue(),
                                $this->attributeRelations['table_prefix']
                            );
                        } else {
                            $newOperatorValue = $attributePropertyMapper
                            ->getPropertyIdByAttributeIdAndLabel(
                                $attribute->getId(),
                                $operator->$getValue(),
                                $this->attributeRelations['table_prefix']
                            );
                        }

                        if (!$newOperatorValue) {
                            return;
                        }

                        $operator->$setIdentifier('attribute_property_id');

                        $operator->$setValue($newOperatorValue);
                        $attributeFilter = array(
                            'attribute_property_id' => $operator
                        );
                    } else {
                        $operator->$setIdentifier('value');
                        $attributeFilter = array(
                            'value' => $operator
                        );
                    }
                    unset($filter[$attributeIdentifier]);
                }

                if (
                    $applyColumnsFilter &&
                    ($colKey = array_search($attributeIdentifier, $columns)) !== false
                ) {
                    // Skip this attribute join when not in selection!
                    unset($columns[$colKey]);
                    $columns = array_values($columns);
                } elseif ($applyColumnsFilter) {
                    if (!empty($attributeFilter)) {
                        $this->addAttributeJoin(
                            $select,
                            $attributeIdentifier,
                            false,
                            $attributeFilter
                        );
                    }
                    continue;
                }
                $this->addAttributeJoin(
                    $select,
                    $attributeIdentifier,
                    true,
                    $attributeFilter
                );
            }
        }

        // Add remaining columns to normal select
        if ($applyColumnsFilter && !empty($columns)) {
            $select->columns($columns);
        }
        /*
         * When surfing through joins and going a level deeper a reference to
         * the current depth gets appended to this array to be able to go
         * back when the nested array has been looped.
         */
        $pointer        = &$joins;
        $joinDepth      = array();
        $ref            = null;
        $columnsPointer = &$joinColumns;
        $filterPointer  = &$filter;
        $orderByPointer = &$orderBy;
        $groupByPointer = &$groupBy;
        while(true && is_array($joins)) {
            $var = each($pointer);
            if ($var === false) {
                if (empty($joinDepth)) {
                    // There is no previous array to jump back to
                    break;
                }
                // Restore current pointer to the previous depth
                $previous       = array_pop($joinDepth);
                $pointer        = &$previous[0];
                $ref            = $previous[1];
                $columnsPointer = &$previous[2];
                $orderByPointer = &$previous[3];
                $groupByPointer = &$previous[4];
                $filterPointer  = &$previous[5];
                // When previous round a filterPointer has been created. Unset
                // the record. Otherwise it will be added to the wheres
                if (
                    array_key_exists($previous[6], $filterPointer) &&
                    empty($filterPointer[$previous[6]])
                ) {
                    unset($filterPointer[$previous[6]]);
                }
                continue;
            }

            /*
             * When the value is an array we want add a join based on the key,
             * store a reference to this join and set the pointer to this array
             * to start the nested loop.
             */
            if (is_array($var['value'])) {
                $joinDepth[] = array(
                    &$pointer,
                    $ref,
                    &$columnsPointer,
                    &$orderByPointer,
                    &$groupByPointer,
                    &$filterPointer,
                    $var['key']
                );

                $ref = $this->addJoin(
                    $select,
                    $var['key'],
                    $ref,
                    ($applyColumnsFilter ?
                        (isset($columnsPointer[$var['key']]) ?
                            $columnsPointer[$var['key']] :
                            array()
                        ) : null
                    ),
                    (isset($filterPointer[$var['key']]) ?
                        $filterPointer[$var['key']] :
                        null
                    )
                );

                /*@var $ref EntityAssociation*/
                $pointer = &$pointer[$var['key']];
                if (
                    is_array($columnsPointer) &&
                    isset($columnsPointer[$var['key']])
                ) {
                    $columnsPointer = &$columnsPointer[$var['key']];
                } else {
                    $columnsPointer[$var['key']] = array();
                    $columnsPointer = &$columnsPointer[$var['key']];
                }
                if (
                    is_array($filterPointer) &&
                    isset($filterPointer[$var['key']])
                ) {
                    $filterPointer = &$filterPointer[$var['key']];
                } else {
                    $filterPointer[$var['key']] = array();
                    $filterPointer = &$filterPointer[$var['key']];
                }
                if (
                    is_array($orderByPointer) &&
                    isset($orderByPointer[$var['key']])
                ) {
                    $orderByPointer          = &$orderByPointer[$var['key']];
                    $orderByPointer['alias'] = $ref->getAlias();
                } else {
                    $orderByPointer[$var['key']] = array();
                    $orderByPointer              = &$orderByPointer[$var['key']];
                }
                if (
                    is_array($groupByPointer) &&
                    isset($groupByPointer[$var['key']])
                ) {
                    $groupByPointer['alias'] = $ref->getAlias();
                    $groupByPointer          = &$groupByPointer[$var['key']];
                } else {
                    $groupByPointer[$var['key']] = array();
                    $groupByPointer              = &$groupByPointer[$var['key']];
                }
                continue;
            }

            $res = $this->addJoin(
                $select,
                $var['value'],
                $ref,
                ($applyColumnsFilter ?
                    (isset($columnsPointer[$var['value']]) ?
                        $columnsPointer[$var['value']] :
                        array()
                    ) : null
                ),
                (isset($filterPointer[$var['value']]) ?
                    $filterPointer[$var['value']] :
                    null
                )
            );

            if (isset($groupByPointer[$var['value']])) {
                $groupByPointer[$var['value']]['alias'] = $res->getAlias();
            }

            if (isset($orderByPointer[$var['value']])) {
                $orderByPointer[$var['value']]['alias'] = $res->getAlias();
            }
        }

        $pointer = &$orderBy;
        $order   = array();
        $applied = false;

        while (true && is_array($orderBy)) {
            $keyValue = each($pointer);

            if ($keyValue === false) {
                if (count($joinDepth) === 0) {
                    break;
                }

                $previous = array_pop($joinDepth);
                $pointer  = &$previous['pointer'];
                $applied  = $previous['applied'];
                continue;
            }

            if (is_array($keyValue['value'])) {
                // continue the loop
                $joinDepth[] = array(
                    'pointer' => &$pointer,
                    'applied' => $applied,
                );

                $pointer = &$keyValue['value'];
                $applied = false;
                continue;
            }

            if ($applied === true) {
                continue;
            }

            $applied = true;

            // Clone pointer to other variable because of weird behaviour
            $column         = $pointer;
            $tableAlias     = null;
            $columnAlias    = null;
            $columnValue    = null;

            foreach ($column as $key => $value) {
                if ($key === 'alias') {
                    $tableAlias = $value;
                    continue;
                }

                if (!is_array($value)) {
                    $columnAlias = $key;
                    $columnValue = $value;
                    continue;
                }
            }

            if (
                $columnAlias !== null &&
                $columnValue !== null
            ) {
                $orderKey = (
                    !empty($tableAlias) ?
                    "{$tableAlias}.{$columnAlias}" :
                    $columnAlias
                );
                $order[$orderKey] = $columnValue;
            }
        }

        $select->order($order);

        $pointer = &$groupBy;
        $group   = array();
        $applied = false;

        while (true && is_array($groupBy)) {
            $keyValue = each($pointer);

            if ($keyValue === false) {
                if (count($joinDepth) === 0) {
                    break;
                }

                $previous = array_pop($joinDepth);
                $pointer = &$previous['pointer'];
                $applied = $previous['applied'];
                continue;
            }

            if (is_array($keyValue['value'])) {
                // continue the loop
                $joinDepth[] = array(
                    'pointer' => &$pointer,
                    'applied' => $applied,
                );

                $pointer = &$keyValue['value'];
                $applied = false;
                continue;
            }

            if ($applied === true) {
                continue;
            }

            $applied = true;

            // Clone pointer to other variable because of weird behaviour
            $column         = $pointer;
            $tableAlias     = null;
            $columnAlias    = null;

            foreach ($column as $key => $value) {
                if ($key === 'alias') {
                    $tableAlias = $value;
                    continue;
                }

                if (!is_array($value)) {
                    $columnAlias = $value;
                    continue;
                }
            }

            if ($columnAlias !== null) {
                $groupColumn = (
                    !empty($tableAlias) ?
                    "{$tableAlias}.{$columnAlias}" :
                    $columnAlias
                );
                $group[] = $groupColumn;
            }
        }

        $select->group($group);

        $where = new \Zend\Db\Sql\Where();
        $applyWhereFilter = false;
        if (is_array($filter)) {
            foreach ($filter as $key => $operator) {
                if ($operator === null) {
                    $operator = new \Zend\Db\Sql\Predicate\IsNull($key);
                }
                if (is_array($operator)) { //Skip join conditions
                    continue;
                }

                if (!($operator instanceof Predicate\PredicateInterface)) {
                    $value    = $operator;
                    $operator = new Operator();
                    $operator->setLeft($key)->setRight($value);
                }

                $this->applyTableAliasToOperator($operator);

                $where->addPredicate($operator);
                $applyWhereFilter = true;
            }
        }

        // Apply filter
        if ($applyWhereFilter) {
            $select->where($where);
        }

        // When debug events are enabled throw some additional events
        // explicit for debugging purposes.
        if ($this->getDebugEventsEnabled()) {
            $this->getEventManager()->trigger(
                'debug_select_sql_generated',
                $this,
                array(
                    'sql' => $this->debugSql($select->getSqlString()),
                )
            );
        }

        $returnData = array();
        try {
            $result = $this->getResult($select);
        }
        catch (InvalidQueryException $exception) {
            throw new Exception\SearchFailedException(
                'Search query failed!',
                0,
                $exception
            );
        }
        /*@var $result \ZendAdditionals\Db\ResultSet\JoinedHydratingResultSet*/

        while ($entity = $result->current($returnEntities)) {
            if ($this->getDebugEventsEnabled()) {
                $this->getEventManager()->trigger(
                    'debug_select_current_result',
                    $this,
                    array(
                        'current' => $entity,
                    )
                );
            }
            if (!$returnEntities && !empty($xmlAttributes)) {
                foreach ($xmlAttributes as $xmlColumn => $filteredXmlFields) {
                    if (null === $entity[$xmlColumn]) {
                        continue;
                    }
                    $xmlData = new \ZendAdditionals\Xml\Object($entity[$xmlColumn]);
                    $entity[$xmlColumn] = $xmlData->getValues($filteredXmlFields);
                }
            }
            if (!$returnEntities && !empty($serializedAttributes)) {
                foreach ($serializedAttributes as $serializedColumn => $filteredSerializedFields) {
                    if (
                        !empty($entity[$serializedColumn]) &&
                        false !== ($unserialized = @unserialize($entity[$serializedColumn]))
                    ) {
                        $entity[$serializedColumn] = array();
                        if (empty($filteredSerializedFields)) {
                            $filteredSerializedFields = array_keys($unserialized);
                        }
                        foreach ($filteredSerializedFields as $filteredField) {
                            if (array_key_exists($filteredField, $unserialized)) {
                                $entity[$serializedColumn][$filteredField] = $unserialized[$filteredField];
                            }
                        }
                    } else {
                        $entity[$serializedColumn] = array();
                    }
                }
            }
            $this->getEventManager()->trigger(
                'search_result_fetched',
                $this,
                array(
                    'entity'    => $entity,
                    'is_entity' => $returnEntities,
                )
            );
            if ($return) {
                $returnData[] = $entity;
            }
            $result->next();
        }
        if ($return) {
            return $returnData;
        }
    }

    /**
     * Apply table alias to operator, operator can be a simple predicate but
     * can also be a predicate set that contains predicate set's with predicates
     *
     * @param mixed $operator
     */
    protected function applyTableAliasToOperator($operator)
    {
        if ($operator instanceof Predicate\PredicateSet) {
            $operatorsArray = $operator->getPredicates();
            // array of arrays and every 2nd item is the operator?? well documented ehh..
            $operators = array();
            foreach ($operatorsArray as $operatorArray) {
                $this->applyTableAliasToOperator($operatorArray[1]);
            }
        } else {
            $getIdentifier = 'getLeft';
            $setIdentifier = 'setLeft';
            if (method_exists($operator, 'getIdentifier')) {
                $getIdentifier = 'getIdentifier';
                $setIdentifier = 'setIdentifier';
            }
            $currentIdentifier = $operator->$getIdentifier();
            if (strpos($currentIdentifier, '.') === false) {
                $operator->$setIdentifier(
                    $this->getTableName() . '.' . $currentIdentifier
                );
            }
        }
    }

    public function exists($field, $value)
    {
        $select = $this->getSelect();
        $select->columns(array($field));
        $select->where(array($field => $value));

        $result = $this->getRow($select);

        return (bool)($result !== false);
    }

    /**
     * Check to see if some data is serialized or not
     *
     * @param string $data serialized data
     * @return boolean
     */
    protected function isSerialized($data) {
        // if it isn't a string, it isn't serialized
        if ( !is_string( $data ) ) {
            return false;
        }
        $data = trim( $data );
        if ('N;' == $data) {
            return true;
        }
        if (!preg_match('/^([adObis]):/', $data, $badions)) {
            return false;
        }
        switch ($badions[1]) {
            case 'a' :
            case 'O' :
            case 's' :
                if (preg_match("/^{$badions[1]}:[0-9]+:.*[;}]\$/s", $data)) {
                    return true;
                }
                break;
            case 'b' :
            case 'i' :
            case 'd' :
                if (preg_match( "/^{$badions[1]}:[0-9.E-]+;\$/", $data))
                    return true;
                break;
        }
        return false;
    }

    protected function initializeRelations()
    {
        if (!$this->attributeRelationsGenerated) {
            if (
                isset($this->attributeRelations['attributes']) &&
                is_array($this->attributeRelations['attributes'])
            ) {
                foreach ($this->attributeRelations['attributes'] as $attributeLabel) {
                    $this->generateAttributeRelation($attributeLabel);
                }
            }
            $this->attributeRelationsGenerated = true;
        }

        if (empty($this->relations)) {
            return;
        }

        if (empty($this->relationsByServiceName)) {
            foreach ($this->relations as $identifier => &$relation) {
                $this->relationsByServiceName[$relation['mapper_service_name']][$identifier] = $relation;
            }
        }
    }

    /**
     * @param string $mapperServiceName
     * @param string $entityIdentifier
     *
     * @return array
     *
     * @throws Exception\UnexpectedValueException
     */
    public function getRelation($mapperServiceName, $entityIdentifier)
    {
        $this->initializeRelations();

        if (!isset($this->relationsByServiceName[$mapperServiceName][$entityIdentifier])) {
            throw new Exception\UnexpectedValueException(
                'Dit not expect the requested relation not to exist.'
            );
        }
        return $this->relationsByServiceName[$mapperServiceName][$entityIdentifier];
    }

    /**
     * Generates the attribute relations
     *
     * @param  string $label
     * @return void
     *
     * @throws Exception\UnexpectedValueException
     */
    protected function generateAttributeRelation($label)
    {
        if (
            !isset($this->attributeRelations['attributes']) ||
            (
                $key = array_search(
                    $label,
                    $this->attributeRelations['attributes']
                )
            ) === false
        ) {
            throw new Exception\UnexpectedValueException(
                'There is no attribute relation defined for label "' .
                $label . '"!'
            );
        }
        $property = is_numeric($key) ? $label : $key;
        if (isset($this->relations[$property])) {
            return;
        }
        if (!isset($this->attributeRelations['table_prefix'])) {
            throw new Exception\UnexpectedValueException(
                'There is no attribute table prefix defined for label "' .
                $label . '"!'
            );
        }
        if (!isset($this->attributeRelations['relation_column'])) {
            throw new Exception\UnexpectedValueException(
                'There is no attribute relation column defined for label "' .
                $label . '"!'
            );
        }
        $this->relations[$property] = array(
            'mapper_service_name'  => AttributeData::SERVICE_NAME,
            'required'             => false,
            'foreign_table_prefix' => $this->attributeRelations['table_prefix'],
            'back_reference'       => array(
                'entity_id' => $this->attributeRelations['relation_column'],
            ),
            'extra_conditions'     => array(
                array(
                    'left' => array(
                        'type'    => self::RELATION_TYPE_FOREIGN,
                        'value'   => 'attribute_id',
                    ),
                    'operand' => self::OPERAND_EQUALS,
                    'right'   => array(
                        'type'     => self::RELATION_TYPE_CALLBACK,
                        'value'    => array(
                            $label,
                            $this->attributeRelations['table_prefix']
                        ),
                        'callback' => array($this, 'getAttributeIdByLabel'),
                    ),
                ),
            ),
        );
    }

    /**
     * Performs some basic initialization setup and checks before
     * running a query
     *
     * @throws Exception\InitializeFailedException
     */
    protected function initialize()
    {
        if ($this->isInitialized) {
            return;
        }

        if (!$this->dbAdapter instanceof Adapter) {
            throw new Exception\InitializeFailedException(
                'No db adapter present for ' . get_class($this)
            );
        }

        if (!$this->hydrator instanceof HydratorInterface) {
            $this->hydrator = new ClassMethods;
        }

        if (!is_object($this->entityPrototype)) {
            throw new Exception\InitializeFailedException(
                'No entity prototype set'
            );
        }

        $this->initializeRelations();

        $this->isInitialized = true;
    }

    /**
     * @param ServiceManager $serviceManager
     * @return AbstractMapper
     */
    public function setServiceManager(ServiceManager $serviceManager)
    {
        $this->serviceManager = $serviceManager;

        if (!$this->serviceManager->has(Attribute::SERVICE_NAME)) {
            $this->serviceManager->setFactory(
                Attribute::SERVICE_NAME,
                'ZendAdditionals\Service\AttributeMapperServiceFactory'
            );
            $this->serviceManager->setFactory(
                AttributeData::SERVICE_NAME,
                'ZendAdditionals\Service\AttributeDataMapperServiceFactory'
            );
            $this->serviceManager->setFactory(
                AttributeProperty::SERVICE_NAME,
                'ZendAdditionals\Service\AttributePropertyMapperServiceFactory'
            );
        }

        return $this;
    }

    /**
     * @return ServiceManager
     */
    public function getServiceManager()
    {
        return $this->serviceManager;
    }

    /**
     * Alias for getServiceManager
     */
    public function getServiceLocator()
    {
        return $this->getServiceManager();
    }

    /**
     * Returns an array of column identifiers used for entities that are related
     *
     * @return array
     */
    public function getEntityAssociationColumns()
    {
        $this->initialize();
        return array_keys($this->relations);
    }

    /**
     * Check if this mapper requires a table prefix
     *
     * @return boolean
     */
    public function getTablePrefixRequired()
    {
        return $this->tablePrefixRequired;
    }

    /**
     * Override the default table for this mapper
     *
     * NOTE: If attempting another override first undo by passing
     * NULL as argument or no variable at all.
     *
     * @param string $tableName
     *
     * @return AbstractMapper
     */
    protected function setTableNameOverride($tableName = null)
    {
        if (null !== $tableName && null !== $this->originalTableName) {
            throw new \Exception(
                'Undo override before attempting another override!'
            );
        }
        if (null === $tableName && null === $this->originalTableName) {
            throw new \Exception(
                'Set override before trying to undo an override!'
            );
        }
        if (null === $tableName) {
            $this->tableName         = $this->originalTableName;
            $this->originalTableName = null;
        } else {
            $this->originalTableName = $this->tableName;
            $this->tableName         = $tableName;
        }
        return $this;
    }

    /**
     * @param string|null $table
     * return Select
     */
    protected function getSelect($table = null)
    {
        $table = $table ?: $this->tableName;
        $this->initialize();
        return $this->getSlaveSql()->select($table);
    }

    /**
     * Get update query builder
     *
     * @param string|null $table
     * @return Update
     */
    protected function getUpdate($table = null)
    {
        $table = $table ?: $this->getTableName();
        $this->initialize();
        return $this->getSql()->update($table);
    }

    /**
     * Get delete query builder
     *
     * @param string|null $table
     * @return Delete
     */
    protected function getDelete($table = null)
    {
        $table = $table ?: $this->getTableName();
        $this->initialize();
        return $this->getSql()->delete($table);
    }

    /**
     * @param Select $select
     * @return JoinedHydratingResultSet
     */
    protected function getResult(Select $select)
    {
        $this->initialize();
        $stmt = $this->getSlaveSql()->prepareStatementForSqlObject($select);
        $resultSet = new JoinedHydratingResultSet(
            $this->getHydrator(),
            $this->getEntityPrototype()
        );

        $resultSet->setEventManager($this->getEventManager());

        $associations = $this->getEntityAssociationsForSelect($select);
        if (!empty($associations)) {
            $associations = array_reverse($associations, true);
            $resultSet->setAssociations($associations);
        }
        /*@var $stmt \Zend\Db\Adapter\Driver\Pdo\Statement*/

        $resultSet->initialize($stmt->execute());

        $this->resetEntityAssociationStorage($select);

        return $resultSet;
    }

    protected function getCount(Select $select)
    {
        $this->initialize();
        $select->columns(
            array('total' => new \Zend\Db\Sql\Expression('COUNT(*)'))
        );
        $stmt = $this->getSlaveSql()->prepareStatementForSqlObject($select);

        $result = $stmt->execute();
        /*@var $result \Zend\Db\Adapter\Driver\Pdo\Result*/

        $total = $result->current();

        return (int)$total['total'];
    }

    protected function getRow(Select $select, $returnEntity = true)
    {
        return $this->getResult($select)
               ->getDataSource()->current($returnEntity);
    }

    protected function getCurrent(Select $select, $returnEntity = true)
    {
        return $this->getResult($select)->current($returnEntity);
    }

    protected function getAll(Select $select, $returnEntity = true)
    {
        $return = array();
        $result = $this->getResult($select);
        /*@var $result \ZendAdditionals\Db\ResultSet\JoinedHydratingResultSet*/

        while ($entity = $result->current($returnEntity)) {
            $return[] = $entity;
            $result->next();
        }
        return $return;
    }

    /**
     * Execute raw statement
     *
     * @param AbstractSql $sql
     * @return \Zend\Db\Adapter\Driver\ResultInterface
     */
    protected function query(AbstractSql $sql)
    {
        $statement = $this->getSql()->prepareStatementForSqlObject($sql);
        return $statement->execute();
    }

    protected function debugSql($sql) {
        $sql = str_replace('"', '`', $sql);
        $sql = preg_replace('/[\r\n]/', '', $sql);
        $sql = preg_replace('/\s+/', ' ', $sql);

        if (
            preg_match_all(
                '/SELECT(.+?)FROM/si',
                $sql,
                $matches,
                PREG_SET_ORDER
            )
        ) {
            foreach ($matches as $match) {
                $sql = str_replace(
                    $match[0],
                    'SELECT' . str_replace(',', ",\n    ", $match[1]) . 'FROM',
                    $sql
                );
            }
        }

        $needles = array(
            '/\s+(FROM|LEFT JOIN|INNER JOIN|RIGHT JOIN|JOIN|' .
                'UNION ALL|WHERE|LIMIT|VALUES|GROUP BY)\s+/',
            '/\s(SELECT)\s+/',
            '/\s+(INSERT INTO|UPDATE INTO|UPDATE|`,)\s+/',
            '/\s+(AND|OR |ORDER)\s+/',
            '/;/',
        );

        $replaces = array(
            "\n$1 \n    ",
            "$1 \n  ",
            "$1 \n  ",
            "\n  $1 ",
            ";\n",
        );

        $nice = preg_replace($needles, $replaces, $sql) . "\n";

        return $nice;
    }

    /**
     * Add a join
     *
     * @param Select $select
     * @param string $entityIdentifier
     * @param EntityAssociation $parentAssociation
     * @param array $columnFilter By default all columns get selected,
     *                            use this array to minimize the selection
     * @param array<Operator> $filters An array containing filters for this join.
     *
     * @return EntityAssociation
     *
     * @throws Exception\UnexpectedValueException
     * @throws Exception\RunTimeException
     */
    protected function addJoin(
        Select $select,
        $entityIdentifier,
        EntityAssociation $parentAssociation = null,
        array $columnFilter = null,
        array $filters = null
    ) {
        $this->initialize();
        // First get the correct mapper
        $mapper = $this;
        if ($parentAssociation instanceof EntityAssociation) {
            $mapper = $parentAssociation->getMapper();
        }

        // Check if the relation information has been defined
        if (!isset($mapper->relations[$entityIdentifier])) {
            throw new Exception\UnexpectedValueException(
                'The given associated entity identifier "' .
                $entityIdentifier . '" is not defined in the relations of ' . get_class($this) . '!'
            );
        }

        $relation = $mapper->relations[$entityIdentifier];

        // Create the entity association based on the relation information
        $entityAssociation = new EntityAssociation(
            $entityIdentifier,
            $mapper::SERVICE_NAME,
            $relation['mapper_service_name']
        );

        if ($parentAssociation instanceof EntityAssociation) {
            $entityAssociation->setParentAlias($parentAssociation->getAlias());
        }

        $joinTableAlias = $this->getTableName();

        if ($parentAssociation instanceof EntityAssociation) {
            $joinTableAlias = $parentAssociation->getAlias();
            if (!$parentAssociation->getRequired()) {
                $entityAssociation->setRequired(false);
            }
        }

        $entityAssociation->setServiceManager($this->getServiceManager());

        $tablePrefix = isset($relation['foreign_table_prefix']) ?
            $relation['foreign_table_prefix'] :
            null;

        if (
            $parentAssociation instanceof EntityAssociation &&
            isset($relation['recursive_table_prefix'])
        ) {
            $tablePrefix = $parentAssociation->getTablePrefix();
        }

        $entityAssociation->setTablePrefix($tablePrefix);

        if (
            !isset($relation['reference']) &&
            !isset($relation['back_reference'])
        ) {
            throw new Exception\UnexpectedValueException(
                'When using joins either reference or back reference must be present!'
            );
        }
        $referenceInformation = isset($relation['reference']) ?
            $relation['reference'] :
            array_flip($relation['back_reference']);

        $predicate = $entityAssociation->getPredicate();


        foreach ($referenceInformation as $myId => $foreignId) {
            $predicate->equalTo(
                $entityAssociation->getAlias() . '.' . $foreignId,
                $joinTableAlias . '.' . $myId,
                Predicate\Predicate::TYPE_IDENTIFIER,
                Predicate\Predicate::TYPE_IDENTIFIER
            );
        }

        if (isset($relation['extra_conditions'])) {
            if (!is_array($relation['extra_conditions'])) {
                throw new Exception\UnexpectedValueException(
                    'extra_conditions should be an array for ' .
                    $entityIdentifier
                );
            }

            foreach ($relation['extra_conditions'] as $relation) {
                $this->addExtraJoin(
                    $relation,
                    $predicate,
                    $entityAssociation,
                    $joinTableAlias
                );
            }
        }

        $allJoinColumns = $entityAssociation->getJoinColumns();
        $joinColumns = array();
        if (is_array($columnFilter)) {
            foreach ($allJoinColumns as $alias => $column) {
                if (array_search($column, $columnFilter) !== false) {
                    $joinColumns[$alias] = $column;
                }
            }
        } else {
            $joinColumns = $allJoinColumns;
        }

        $joinPredicate = $entityAssociation->getPredicate();
        if ($this->getAllowFilters() && !empty($filters)) {
            foreach ($filters as $key => $operator) {
                if (is_array($operator)) {
                    continue;
                }
                if ($operator === null) {
                    $operator = new \Zend\Db\Sql\Predicate\IsNull($key);
                }

                if (!($operator instanceof \Zend\Db\Sql\Predicate\PredicateInterface)) {
                    $value    = $operator;
                    $operator = new Operator();
                    $operator->setLeft($key)->setRight($value);
                }

                /**
                 * Flat operators to prepend aliases
                 */
                $flattenOperators = function($operator, array &$operators, $me) {
                    if (($operator instanceof Predicate\PredicateSet) === false) {
                        $operators[] = $operator;
                        return;
                    }

                    $operatorsArray = $operator->getPredicates();

                    foreach ($operatorsArray as $operatorArray) {
                        $me($operatorArray[1], $operators, $me);
                    }
                };

                // Flatten operators
                $operators = array();
                $flattenOperators($operator, $operators, $flattenOperators);

                foreach ($operators as &$item) {
                    $getIdentifier = 'getLeft';
                    $setIdentifier = 'setLeft';

                    if (method_exists($item, 'getIdentifier')) {
                        $getIdentifier = 'getIdentifier';
                        $setIdentifier = 'setIdentifier';
                    }

                    $currentIdentifier = $item->$getIdentifier();
                    if (strpos($currentIdentifier, '.') === false) {
                        $item->$setIdentifier(
                            $entityAssociation->getAlias() . '.' . $currentIdentifier
                        );
                    }
                }
                if (!($operator instanceof Predicate\PredicateInterface)) {
                    // Skip non predicates
                    continue;
                }
                $joinPredicate->addPredicate($operator);
            }
        } else if ($this->getAllowFilters() === false && !empty($filters)){
            $class = get_class($this);
            throw new Exception\RuntimeException(
                "You tried to apply filters on a join. " .
                "But {$class}::getAllowFilters() returned false. ".
                "override {$class}::getAllowFilters() and return true " .
                "to allow filtering on a join."
            );
        }

        $select->join(
            $entityAssociation->getJoinTable(),
            $joinPredicate,
            $joinColumns,
            $entityAssociation->getJoinType()
        );

        $this->storeEntityAssociationToSelect($select, $entityAssociation);

        return $entityAssociation;
    }

    /**
     * Adds an attribute relation
     *
     * @param string $attribute The identifier of the attribute
     */
    protected function addAttributeRelation($attribute)
    {
        if (!is_array($this->attributeRelations)) {
            $this->attributeRelations = array();
        }
        if (!isset($this->attributeRelations['attributes'])) {
            $this->attributeRelations['attributes'] = array();
        }
        if (
            false === array_search(
                $attribute, $this->attributeRelations['attributes']
            )
        ) {
            $this->attributeRelations['attributes'][] = $attribute;
        }
    }

    /**
     * Set the attribute relations, note previously set attribute
     * relations will be replaced.
     *
     * @param array $attributes
     *
     * @return AbstractMapper
     */
    protected function setAttributeRelations(array $attributes)
    {
        if (!is_array($this->attributeRelations)) {
            $this->attributeRelations = array(
                'attributes'      => array(),
                'table_prefix'    => $this->getTableName() . '_',
                'relation_column' => 'id'
            );
        }
        $this->attributeRelations['attributes'] = $attributes;
        return $this;
    }

    /**
     * Create joins for all possible attributes
     *
     * @param Select $select
     */
    protected function addAttributeJoins(
        Select $select,
        $addSelectionColumns = true
    ) {
        if (
            isset($this->attributeRelations['attributes']) &&
            is_array($this->attributeRelations['attributes'])
        ) {
            foreach ($this->attributeRelations['attributes'] as $attribute) {
                $this->addAttributeJoin($select, $attribute, $addSelectionColumns);
            }
        }
    }

    /**
     * Create join for a specific attribute
     *
     * @param Select $select
     * @param type $attribute
     */
    protected function addAttributeJoin(
        Select $select,
        $attribute,
        $addSelectionColumns = true,
        array $attributeDataFilters = null
    ) {
        $ref = $this->addJoin(
            $select,
            $attribute,
            null,
            $addSelectionColumns ? null : array(),
            $attributeDataFilters
        );
        $this->addJoin(
            $select,
            'attribute',
            $ref,
            $addSelectionColumns ? null : array()
        );
        $this->addJoin(
            $select,
            'attribute_property',
            $ref,
            $addSelectionColumns ? null : array()
        );
    }

    /**
     * Generates extra joins based on the information provider in the
     * relations extra_conditions
     *
     * @param array $extraJoin      This is the array defined in the
     *                              relations section of the mapper
     * @param Predicate $predicate  The predicate that will be used for
     *                              the joins
     * @param EntityAssociation $entityAssociation The entityAssociation that
     *                                             controls the join
     *
     * @return void
     * @throws Exception\UnexpectedValueException
     */
    protected function addExtraJoin(
        $extraJoin,
        Predicate\Predicate $predicate,
        EntityAssociation $entityAssociation,
        $myJoinAlias
    ) {
        $diff = array_diff_key(
            array_flip($this->extraJoinRequiredKeys),
            $extraJoin
        );
        if (count($diff) > 0) {
            throw new Exception\UnexpectedValueException(
                'Following keys should be set for extra join: ' .
                implode(', ', array_keys($diff))
            );
        }

        list($leftValue, $leftType) = $this->normalizeValueTypeForPredicate(
            $extraJoin['left'],
            $entityAssociation->getAlias(),
            $myJoinAlias
        );

        list($rightValue, $rightType) = $this->normalizeValueTypeForPredicate(
            $extraJoin['right'],
            $entityAssociation->getAlias(),
            $myJoinAlias
        );

        // Call the correct predicate function based operand provided
        switch($extraJoin['operand']) {
            case self::OPERAND_EQUALS:
            case self::OPERAND_NOT_EQUALS:
            case self::OPERAND_LESS:
            case self::OPERAND_LESS_OR_EQUALS:
            case self::OPERAND_MORE:
            case self::OPERAND_MORE_OR_EQUALS:
                $predicate->addPredicate(
                    new Operator(
                        $leftValue,
                        $extraJoin['operand'],
                        $rightValue,
                        $leftType,
                        $rightType
                    )
                );
                break;
            default:
                throw new Exception\UnexpectedValueException(
                    'operand `' . $extraJoin['operand'] . '` not implemented'
                );
                break;
        }
    }

    /**
     * Get a list of possible enumerations. When a label is provided only
     * the values for that label get returned.
     *
     * @return array List of possible enumerations like:
     * array(
     *     'label' => array(
     *         'val_1,
     *         'val_2',
     *         ...
     *     ),
     * ); or with label:
     * array(
     *     'val_1,
     *     'val_2',
     *     ...
     * );
     */
    public function getEnumAttributes($label = null)
    {
        $attributeMapper = $this->getServiceManager()->get(Attribute::SERVICE_NAME);
        /* @var $attributeMapper \ZendAdditionals\Db\Mapper\Attribute */
        $attributePropertyMapper = $this->getServiceManager()->get(AttributeProperty::SERVICE_NAME);
        /* @var $attributePropertyMapper \ZendAdditionals\Db\Mapper\AttributeProperty */
        $attributes = $attributeMapper->getAllAttributes($this->getAttributeTablePrefix());
        $return = array();
        if (empty($attributes)) {
            return $return;
        }
        foreach ($attributes['by_label'] as $attribute) {
            if ($attribute->getType() !== 'enum') {
                continue;
            }
            if (null !== $label && $label !== $attribute->getLabel()) {
                continue;
            }
            $properties = $attributePropertyMapper->getPropertiesByAttributeId(
                $attribute->getId(),
                $this->getAttributeTablePrefix()
            );
            foreach ($properties as $property) {
                $return[$attribute->getLabel()][] = $property->getLabel();
            }
        }
        return (null !== $label && isset($return[$label])) ? $return[$label] : $return;
    }

    public function getAttributeIdByLabel($label, $tablePrefix)
    {
        /*@var $attributeMapper Attribute*/
        $attributeMapper = $this->getServiceManager()->get(Attribute::SERVICE_NAME);
        return $attributeMapper->getIdByLabel($label, $tablePrefix);
    }


    /**
     * This will normalize the value and type parameters to the predicate format
     *
     * @param array $extraJoin      This is the array defined in the relations
     *                              section of the mapper
     * @param mixed $foreignAlias   The alias that will be used if the
     *                              type is foreign
     * @param mixed $myAlias
     *
     * @throws Exception\UnexpectedValueException
     */
    protected function normalizeValueTypeForPredicate(
        $extraJoin,
        $foreignAlias,
        $myAlias
    ) {
        $diff = array_diff_key(
            array_flip($this->extraJoinColumnRequiredKeys),
            $extraJoin
        );
        if (count($diff) > 0) {
            throw new Exception\UnexpectedValueException(
                'Following keys should be set for extraJoin: ' .
                implode(', ', array_keys($diff))
            );
        }

        $type     = $extraJoin['type'];
        $value    = $extraJoin['value'];
        $callback = isset($extraJoin['callback']) ?
            $extraJoin['callback'] :
            null;

        switch ($type) {
            case self::RELATION_TYPE_FOREIGN:
                $type = Predicate\Predicate::TYPE_IDENTIFIER;
                $value = $foreignAlias.'.'.$value;
                break;
            case self::RELATION_TYPE_MY:
                $type = Predicate\Predicate::TYPE_IDENTIFIER;
                $value = $myAlias.'.'.$value;
                break;
            case self::RELATION_TYPE_VALUE:
                $type = Predicate\Predicate::TYPE_VALUE;
                break;
            case self::RELATION_TYPE_CALLBACK:
                $type = Predicate\Predicate::TYPE_VALUE;

                if (!is_callable($callback)) {
                    throw new Exception\UnexpectedValueException(
                        $callback . ' is not callable'
                    );
                }

                $value = call_user_func_array($callback, $value);
                break;
            default:
                throw new Exception\UnexpectedValueException(
                    $type . ' extra_condition type is not implemented'
                );
                break;
        }

        return array($value, $type);
    }

    private function storeEntityAssociationToSelect(
        Select $select,
        EntityAssociation $entityAssociation
    ) {
        if (!($this->entityAssociationStorage instanceof \SplObjectStorage)) {
            $this->entityAssociationStorage = new \SplObjectStorage();
        }
        if (!$this->entityAssociationStorage->contains($select)) {
            $this->entityAssociationStorage->attach($select, array());
        }
        $data = $this->entityAssociationStorage[$select];
        $data[$entityAssociation->getAlias()]    = $entityAssociation;
        $this->entityAssociationStorage[$select] = $data;
    }

    private function getEntityAssociationsForSelect(Select $select)
    {
        if (
            !($this->entityAssociationStorage instanceof \SplObjectStorage) ||
            !$this->entityAssociationStorage->contains($select)
        ) {
            return;
        }
        return $this->entityAssociationStorage[$select];
    }

    private function resetEntityAssociationStorage(Select $select)
    {
        if (
            !($this->entityAssociationStorage instanceof \SplObjectStorage) ||
            !$this->entityAssociationStorage->contains($select)
        ) {
            return;
        }
        $this->entityAssociationStorage->detach($select);
    }

    public function underscoreToCamelCase($underscored)
    {
        $underscored = strtolower($underscored);
        return preg_replace('/_(.?)/e',"strtoupper('$1')",$underscored);
    }

    /**
     * Return the last error that occured during query execution
     *
     * @return Collection\Error
     */
    public function getLastErrors()
    {
        return $this->lastErrors;
    }

    /**
     * Commit transaction
     *
     * @return void
     * @throws Excception\LogicException
     */
    public function startTransaction()
    {
        if ($this->getTransactionStarted() === true) {
            throw new Exception\LogicException('Transaction already started');
        }

        try {
            $this->getDbAdapter()->getDriver()->getConnection()->beginTransaction();
        } catch (\Zend\Db\Exception\ExceptionInterface $e) {
            throw new Exception\LogicException(
                'Something went wrong with starting the transaction',
                null,
                $e
            );
        }

        self::$transactionStarted = true;
    }

    /**
     * Commit transaction
     *
     * @return void
     * @throws Excception\LogicException
     */
    public function rollback()
    {
        if ($this->getTransactionStarted() === false) {
            throw new Exception\LogicException('Transaction has not been started');
        }

        try {
            $this->getDbAdapter()->getDriver()->getConnection()->rollback();
        } catch (\Zend\Db\Exception\ExceptionInterface $e) {
            throw new Exception\LogicException(
                'Something went wrong with rollback the transaction',
                null,
                $e
            );
        }

        self::$transactionStarted = false;
    }

    /**
     * Commit transaction
     *
     * @return void
     * @throws Excception\LogicException
     */
    public function commit()
    {
        if ($this->getTransactionStarted() === false) {
            throw new Exception\LogicException('Transaction has not been started');
        }

        try {
            $this->getDbAdapter()->getDriver()->getConnection()->commit();
        } catch (\Zend\Db\Exception\ExceptionInterface $e) {
            throw new Exception\LogicException(
                'Something went wrong with commiting the data',
                null,
                $e
            );
        }

        self::$transactionStarted = false;
    }

    /**
     * Returns if there is already a transaction running
     *
     * @return boolean
     */
    public function getTransactionStarted()
    {
        return self::$transactionStarted;
    }

    /**
     * Save the given entity
     *
     * @param AbstractDbEntity $entity
     * @param string $tablePrefix
     * @param array  $parentRelationInfo When this save is called from a parent antity
     * the relational info from the parent is passed thru.
     *
     * @return ResultInterface|bool Boolean true gets returned
     * when there is nothing to update. FALSE on failure. Call getLastErrors() for error
     * information
     *
     * @throws \ZendAdditionals\Db\Mapper\Exception\SaveFailedException
     * @throws \ZendAdditionals\Db\Mapper\Exception\UnexpectedValueException
     */
    public function save(
        AbstractDbEntity $entity,
        $tablePrefix              = null,
        array $parentRelationInfo = null,
        $useTransaction           = true
    ) {
        static $parentSave = true;
        $parentSaveSet     = false;

        // This is the intitial call. Set identifier variable for this method
        if ($parentSave === true) {
            $parentSave    = false;
            $parentSaveSet = true;
        }

        try {
            if ($this->getTablePrefixRequired() && empty($tablePrefix)) {
                throw new Exception\UnexpectedValueException(
                    'This mapper requires a table prefix to ' .
                    'be given when calling save.'
                );
            }

            $this->initialize();

            $className = get_class($entity);

            // Validate if the entity belongs to the mapper
            $this->validateEntity($entity);
        } catch (\Exception $exception) {
            throw new Exception\SaveFailedException(
                'Mapper ' . get_called_class() . ' could not store entity: ' . get_class($entity),
                0,
                $exception
            );
        }
        $this->getEventManager()->trigger(
            'preSave',
            $this,
            array(
                'entity'                => $entity,
                'table_prefix'          => $tablePrefix,
                'parent_relation_info'  => $parentRelationInfo,
            )
        );

        if ($parentSaveSet === true) {
            $this->getEventManager()->trigger(
                'preParentSave',
                $this,
                array(
                    'entity'                => $entity,
                    'table_prefix'          => $tablePrefix,
                    'parent_relation_info'  => $parentRelationInfo,
                )
            );
        }

        $hydrator = $this->getHydrator();

        $result                  = false;
        $transactionStarted      = false;
        $this->lastErrors        = new Collection\Error();
        $insert                  = false;
        $entityModified          = true;

        // For whole entities we want to trigger the entity specific pre_save
        if (!($this instanceof AttributeData)) {
            // Post save event for hydration purposes
            $results = $this->getEventManager()->trigger(
                static::SERVICE_NAME . '::entity_pre_save',
                $this,
                array(
                    'entity'       => $entity,
                    'table_prefix' => $tablePrefix,
                )
            );

            $lastResult = $results->last();
            if (null !== $lastResult) {
                $entity = $lastResult;
            }
        }

        try {
            if ($useTransaction && $this->getTransactionStarted() === false) {
                $this->startTransaction();
                $transactionStarted = true;
            }

            if (
                $hydrator->hasOriginal($entity) &&
                !$this->isEntityEmpty($entity, true)
            ) {
                $result = $this->update(
                    $entity,
                    null,
                    $hydrator,
                    $tablePrefix,
                    $attributeDataModified,
                    $relatedEntitiesModified
                );
                // true comes back when no columns are changed
                if (
                    true === $result &&
                    true !== $attributeDataModified &&
                    true !== $relatedEntitiesModified
                ) {
                    $entityModified = false;
                }
            } else {
                $insert = true;
                $result = $this->insert($entity, $hydrator, $tablePrefix);
            }

            // Only commit when transaction has been triggered by us
            if ($transactionStarted === true) {
                $this->commit();
            }
        } catch (\Zend\Db\Exception\ExceptionInterface $exception) {
            // Only rollback when transaction has been triggered by us
            if ($transactionStarted) {
                $this->rollback();
            }
            throw new Exception\SaveFailedException(
                'Mapper ' . get_called_class() . ' could not store entity: ' . get_class($entity),
                0,
                $exception
            );
        } catch (Exception\SaveFailedException $exception) {
            // Only rollback when transaction has been triggered by us
            if ($transactionStarted) {
                $this->rollback();
            }
            throw new Exception\SaveFailedException(
                'Mapper ' . get_called_class() . ' could not store entity: ' . get_class($entity),
                0,
                $exception
            );
        }

        // Post save event for hydration purposes
        $this->getEventManager()->trigger(
            'postSave',
            $this,
            array('entity' => $entity)
        );

        if ($parentSaveSet === true) {
            $this->getEventManager()->trigger(
                'postParentSave',
                $this,
                array(
                    'entity'                => $entity,
                    'table_prefix'          => $tablePrefix,
                    'parent_relation_info'  => $parentRelationInfo,
                )
            );
        }

        // For whole entities we want to trigger the entity specific saves event
        if (!($this instanceof AttributeData)) {
            $this->getEventManager()->trigger(
                static::SERVICE_NAME . '::entity_saved',
                $this,
                array(
                    'entity'          => $entity,
                    'inserted'        => $insert,
                    'table_prefix'    => $tablePrefix,
                    'entity_modified' => $entityModified,
                )
            );
        }

        // If this is the intitial call. We reset the $parentSave variable
        if ($parentSaveSet === true) {
            $parentSave = true;
        }

        return $result;
    }

    /**
     * @param AbstractDbEntity $entity
     * @param ObservableStrategyInterface|null $hydrator
     *
     * @return ResultInterface
     */
    protected function insert(
        AbstractDbEntity $entity,
        ObservableStrategyInterface $hydrator = null,
        $tablePrefix = null
    ) {
        $this->storeRelatedEntities($entity, $tablePrefix, true);

        $this->initialize();
        $tableName = $this->getTableName();

        if (!empty($tablePrefix)) {
            $tableName = $tablePrefix . $tableName;
        }

        $sql = $this->getSql()->setTable($tableName);
        $insert = $sql->insert();

        if (!empty($this->autoGenerated)) {
            $autoGeneratedGet = 'get' . ucfirst($this->autoGenerated);
            if (null !== ($autoGeneratedValue = $entity->$autoGeneratedGet())) {
                throw new Exception\InsertFailedException(
                    'Can not insert data that already ' .
                    'has an auto generated value "' . $autoGeneratedValue . '"!'
                );
            }
        }

        $rowData = $this->entityToArray($entity, $hydrator);

        // Put in better function
        $associatedColumns = $this->getEntityAssociationColumns();
        foreach ($associatedColumns as $associatedColumn) {
            if (array_key_exists($associatedColumn, $rowData)) {
                unset($rowData[$associatedColumn]);
            }
        }

        // If applicable remove auto generated column for insert
        if (!empty($this->autoGenerated)) {
            unset($rowData[$this->autoGenerated]);
        }

        $insert->values($rowData);

        $statement = $sql->prepareStatementForSqlObject($insert);

        // When debug events are enabled throw some additional events
        // explicit for debugging purposes.
        if ($this->getDebugEventsEnabled()) {
            $this->getEventManager()->trigger(
                'debug_save_sql_generated',
                $this,
                array(
                    'sql' => $this->debugSql($insert->getSqlString()),
                )
            );
        }

        /*@var $statement \Zend\Db\Adapter\Driver\Pdo\Statement*/
        $result = $statement->execute();
        /*@var $result \Zend\Db\Adapter\Driver\Pdo\Result*/

        if (
            null !== $this->autoGenerated &&
            null !== ($generatedValue = $result->getGeneratedValue())
        ) {
            $autoGeneratedSet = 'set' . ucfirst($this->autoGenerated);
            $entity->$autoGeneratedSet($generatedValue);
        }

        $hydrator->setChangesCommitted($entity);

        $this->storeRelatedEntities($entity, $tablePrefix);

        return $this->save($entity, $tablePrefix, null, false);
    }

    /**
     * Delete a single entity from the database
     *
     * @param AbstractDbEntity $entity
     * @param ObservableStrategyInterface $hydrator
     * @param mixed $tablePrefix
     * @return \Zend\Db\Adapter\Driver\ResultInterface
     */
    public function delete(
        AbstractDbEntity $entity,
        ObservableStrategyInterface $hydrator = null,
        $tablePrefix = null
    ) {
        $this->initialize();

        // Validate if the entity belongs to the mapper
        $this->validateEntity($entity);

        $tableName = $this->getTableName();
        if (!empty($tablePrefix)) {
            $tableName = $tablePrefix . $tableName;
        }

        $sql = $this->getSql()->setTable($tableName);
        $delete = $sql->delete();

        $where = $this->getPrimaryData(
            $this->entityToArray($entity, $hydrator)
        );

        $delete->where($where);

        $statement = $sql->prepareStatementForSqlObject($delete);
        /*@var $statement \Zend\Db\Adapter\Driver\Pdo\Statement*/

        try {
            $result = $statement->execute();
            // Entity deleted with success, trigger event
            // For whole entities we want to trigger the entity specific saves event
            $this->getEventManager()->trigger(
                static::SERVICE_NAME . '::entity_deleted',
                $this,
                array(
                    'entity'       => $entity,
                    'table_prefix' => $tablePrefix,
                )
            );
        } catch (\Zend\Db\Exception\ExceptionInterface $e) {
            throw new Exception\DeleteFailedException(
                "Could not delete record with entity: " . var_export($entity, true),
                0,
                $e
            );
        }

        // Destruct the entity
        $entity->__destruct();

        return $result;
    }

    /**
     * Delete a list of entities
     *
     * @param array $entities
     * @param ObservableStrategyInterface $hydrator
     * @param string $tablePrefix
     * @return \Zend\Db\Adapter\Driver\ResultInterface | boolean TRUE when $entities is empty
     */
    public function deleteMultiple(
        array $entities,
        ObservableStrategyInterface $hydrator = null,
        $tablePrefix = null
    ) {
        $where                  = array();
        $useInQuery             = false;
        $primaryTypeIdentified  = false;

        // When no entities are given return, because otherwise all the records will be deleted.
        if (empty($entities)) {
            return true;
        }
        foreach ($entities as $entity) {
            // Validate if the entity belongs to the mapper
            $this->validateEntity($entity);

            $primaryData = $this->getPrimaryData(
                $this->entityToArray($entity, $hydrator)
            );
            if ($primaryTypeIdentified === false) {
                $primaryTypeIdentified  = true;
                $useInQuery = (bool) (count($primaryData) === 1);
            }
            // Simple one primary tables can use the IN query
            if ($useInQuery === true) {
                $value = each($primaryData);
                $where[$value['key']][] = $value['value'];
                continue;
            }
            // X-coss tables with n-primaries. Use full written wheres
            $predicate = new Predicate\PredicateSet();
            foreach($primaryData as $key => $value) {
                $predicate->addPredicate(
                    new Predicate\Operator(
                        $key,
                        Predicate\Operator::OPERATOR_EQUAL_TO,
                        $value
                    )
                );
            }
            $where[] = $predicate;
        }

        $this->initialize();
        $tableName = $this->getTableName();
        if (!empty($tablePrefix)) {
            $tableName = $tablePrefix . $tableName;
        }

        $sql = $this->getSql()->setTable($tableName);
        $delete = $sql->delete();

        $delete->where($where, Predicate\PredicateSet::OP_OR);

        /** @var $statement \Zend\Db\Adapter\Driver\Pdo\Statement*/
        $statement = $sql->prepareStatementForSqlObject($delete);

        try {
            $result = $statement->execute();
            // Entity deleted with success, trigger event
            // For whole entities we want to trigger the entity specific saves event
            foreach ($entities as $entity) {
                $this->getEventManager()->trigger(
                    static::SERVICE_NAME . '::entity_deleted',
                    $this,
                    array(
                        'entity' => $entity,
                    )
                );
            }
        } catch (\Zend\Db\Exception\ExceptionInterface $e) {
            throw new Exception\DeleteFailedException(
                "Could not delete multiple record",
                0,
                $e
            );
        }

        // Memory optimalization
        foreach ($entities as $entity) {
            $entity->__destruct();
        }

        return $result;
    }

    protected function unsetRelatedEntityColumns($entityArray)
    {
        $columns = $this->getEntityAssociationColumns();
        foreach ($columns as $column) {
            if (array_key_exists($column, $entityArray)) {
                unset($entityArray[$column]);
            }
        }
        return $entityArray;
    }

    /**
     * Get relation information
     *
     * @param  string $relationIdentifier
     *
     * @return array  Containing all the information about the relation
     *
     * @throws Exception\RelationNotFoundException
     */
    protected function getRelationInfo($relationIdentifier)
    {
        if (!isset($this->relations[$relationIdentifier])) {
            throw new Exception\RelationNotFoundException(
                'relation not found'
            );
        }
        return $this->relations[$relationIdentifier];
    }

    /**
     * Get the relating mapper service
     *
     * @param  string $relationIdentifier
     *
     * @return AbstractMapper
     *
     * @throws Exception\RelationMapperServiceNotFoundException
     */
    protected function getMapperForRelation($relationIdentifier)
    {
        $relationInfo = $this->getRelationInfo($relationIdentifier);
        try {
            /* @var $relationServiceMapper AbstractMapper */
            return $this->getServiceManager()->get(
                $relationInfo['mapper_service_name']
            );
        } catch (ServiceNotFoundException $exception) {
            throw new Exception\RelationMapperServiceNotFoundException(
                '',
                0,
                $exception
            );
        }
    }

    /**
     * Stores the related entities for the given entity
     *
     * @param AbstractDbEntity  $entity
     * @param string  $tablePrefix
     * @param boolean $ignoreEntitiesThatRequireBase
     * @param boolean $attributeDataModified
     * @param boolean $relatedEntitiesModified
     */
    protected function storeRelatedEntities(
         AbstractDbEntity $entity,
         $tablePrefix                   = null,
         $ignoreEntitiesThatRequireBase = false,
        &$attributeDataModified         = false,
        &$relatedEntitiesModified       = false
    ) {
        $this->initialize();
        foreach ($this->relations as $entityIdentifier => $relationInfo) {
            $getAssociatedEntity = $this->underscoreToCamelCase(
                'get_' . $entityIdentifier
            );
            $associatedEntity = $entity->$getAssociatedEntity();

            /* @var $relationServiceMapper AbstractMapper */
            $relationServiceMapper = $this->getServiceManager()->get(
                $relationInfo['mapper_service_name']
            );

            /*
             * The associated entity is null when not added to the join when
             * selecting and the associated entity is empty when it has been
             * added to the join but does not exist in the database
             * (left outer join)
             */
            if (
                is_null($associatedEntity) ||
                $relationServiceMapper->isEntityEmpty($associatedEntity)
            ) {
                continue;
            }

            // Check if the base entity has a relation to the associated entity
            $entityHasReferenceToAssociation = isset($relationInfo['reference']);


            // Check if the associated entity has a relation back to me
            $associationHasBackReference = isset($relationInfo['back_reference']);

            /*
             * When the associated entity relates back check if we want
             * to ignore this entity
             */
            if ($associationHasBackReference && $ignoreEntitiesThatRequireBase) {
                continue;
            }

            // Set the relation id's when the association relates back
            if ($associationHasBackReference) {
                foreach ($relationInfo['back_reference'] as $foreignId => $myId) {
                    // Set id from entity into associated entity
                    $getMyId      = $this->underscoreToCamelCase('get_' . $myId);
                    $setForeignId = $this->underscoreToCamelCase('set_' . $foreignId);
                    $associatedEntity->$setForeignId($entity->$getMyId());
                }
            }

            /*
             * Set the table prefix to null when a recursive
             * prefix is not required
             */
            if (
                !isset($relationInfo['recursive_table_prefix']) ||
                !$relationInfo['recursive_table_prefix']
            ) {
                $tablePrefix = null;
            }

            // When the association requires a prefix we will set this
            // (this has nothing to do with recursion)
            if (isset($relationInfo['foreign_table_prefix'])) {
                $tablePrefix = $relationInfo['foreign_table_prefix'];
            }

            // Save the associated entity
            $result = $relationServiceMapper->save(
                $associatedEntity,
                $tablePrefix,
                $relationInfo,
                false
            );

            if ($associatedEntity instanceof \ZendAdditionals\Db\Entity\AttributeData &&
                $result instanceof ResultInterface
            ) {
                $attributeDataModified   = true;
            } elseif ($result instanceof ResultInterface) {
                $relatedEntitiesModified = true;
            }

            // Set id from associated entity into entity (if applicable)
            if ($entityHasReferenceToAssociation) {
                foreach ($relationInfo['reference'] as $myId => $foreignId) {
                    $setMyId = $this->underscoreToCamelCase(
                        'set_' . $myId
                    );
                    $getForeignId = $this->underscoreToCamelCase(
                        'get_' . $foreignId
                    );
                    $entity->$setMyId($associatedEntity->$getForeignId());
                }
            }
        }
    }

    protected function setChangesCommittedOnRelatedEntities(AbstractDbEntity $entity)
    {
        $this->initialize();
        foreach ($this->relations as $entityIdentifier => $relationInfo) {
            $getAssociatedEntity = $this->underscoreToCamelCase(
                'get_' . $entityIdentifier
            );
            $associatedEntity = $entity->$getAssociatedEntity();

            /* @var $relationServiceMapper AbstractMapper */
            $relationServiceMapper = $this->getServiceManager()->get(
                $relationInfo['mapper_service_name']
            );

            /*
             * The associated entity is null when not added to the join when
             * selecting and the associated entity is empty when it has been
             * added to the join but does not exist in the database
             * (left outer join)
             */
            if (
                is_null($associatedEntity) ||
                $relationServiceMapper->isEntityEmpty($associatedEntity)
            ) {
                continue;
            }

            // Save the associated entity
            $relationServiceMapper->setChangesCommitted($associatedEntity);
        }
    }

    protected function setChangesCommitted(AbstractDbEntity $entity)
    {
        $this->setChangesCommittedOnRelatedEntities($entity);
        if (
            $this->isEntityEmpty($entity) ||
            (
                $entity instanceof \ZendAdditionals\Db\Entity\AttributeData &&
                (
                    null == $entity->getEntityId() ||
                    null == $entity->getAttributeId()
                )
            )
        ) {
            // We want to skip committing changes on new AttributeData objects
            // and empty entities
            return;
        }
        $this->getHydrator()->setChangesCommitted($entity);
    }

    /**
     * @param object|array $entity
     * @param string|array|closure $where
     * @param ObservableStrategyInterface|null $hydrator
     * @param string  $tablePrefix
     * @param boolean $attributeDataModified Becomes true when related attribute data
     * is changed, use of this variable is by reference.
     * @param boolean $relatedEntitiesModified Becomes true when related
     * entities are changed, use of this variable is by reference.
     *
     * @return ResultInterface|boolean true when there are no changes mage
     */
    protected function update(
        AbstractDbEntity            $entity,
                                    $where                   = null,
        ObservableStrategyInterface $hydrator                = null,
                                    $tablePrefix             = null,
                                   &$attributeDataModified   = false,
                                   &$relatedEntitiesModified = false
    ) {
        $this->storeRelatedEntities(
            $entity,
            $tablePrefix,
            false,
            $attributeDataModified,
            $relatedEntitiesModified
        );

        $this->initialize();
        $tableName = $this->getTableName();
        if (!empty($tablePrefix)) {
            $tableName = $tablePrefix . $tableName;
        }

        $sql = $this->getSql()->setTable($tableName);
        $update = $sql->update();

        $originalData = array();
        $changedData  = $this->entityToArray($entity, $hydrator, true, $originalData);
        $changedData  = $this->unsetRelatedEntityColumns($changedData);

        if (empty($changedData)) {
            return true;
        }

        if (empty($where)) {
            if ($this->isPrimaryKeyChanged($changedData)) {
                $previousPrimaryData = $this->getPrimaryData($originalData);

                if (empty($previousPrimaryData)) {
                    throw new Exception\UpdateFailedException(
                        'Update called for non existing entity, must be fixed!'
                    );
                }
                $where = $previousPrimaryData;
            } else {
                $where = $this->getPrimaryData(
                    $this->entityToArray($entity, $hydrator)
                );

                if (empty($where)) {
                    throw new Exception\UpdateFailedException(
                        'Missing primary columns. Cannot update record!'
                    );
                }
            }
        }

        $update->set($changedData)
            ->where($where);

        $statement = $sql->prepareStatementForSqlObject($update);
        /*@var $statement \Zend\Db\Adapter\Driver\Pdo\Statement*/

        // When debug events are enabled throw some additional events
        // explicit for debugging purposes.
        if ($this->getDebugEventsEnabled()) {
            $this->getEventManager()->trigger(
                'debug_save_sql_generated',
                $this,
                array(
                    'sql' => $this->debugSql($update->getSqlString()),
                )
            );
        }

        $result = $statement->execute();

        $hydrator->setChangesCommitted($entity);

        return $result;
    }

    /**
     * Check for a specific entity if the primary key has been changed
     *
     * @return boolean
     */
    protected function isPrimaryKeyChanged(array $changedData)
    {
        foreach ($this->primaries as $primary) {
            foreach ($primary as $key) {
                if (isset($changedData[$key])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Extract the primary data from an array of data extracted from the entity,
     * this should be the original data provided by reference when
     * calling entityToArray
     *
     * @param array $data
     *
     * @return array
     */
    protected function getPrimaryData(array $data)
    {
        $return = array();
        foreach ($this->primaries as $primary) {
            foreach ($primary as $key) {
                if (isset($data[$key])) {
                    $return[$key] = $data[$key];
                }
            }
        }
        return $return;
    }

    /**
     * Overwrite the default table name if necessary
     *
     * @param string $tableName
     *
     * @return AbstractMapper
     */
    public function setTableName($tableName)
    {
        $this->tableName = $tableName;
        return $this;
    }

    /**
     * @return string
     */
    public function getTableName()
    {
        return $this->tableName;
    }

    /**
     * @return object
     */
    public function getEntityPrototype()
    {
        return $this->entityPrototype;
    }

    /**
     * @param object $modelPrototype
     * @return AbstractDbMapper
     */
    public function setEntityPrototype($entityPrototype)
    {
        $this->entityPrototype = $entityPrototype;
        return $this;
    }

    /**
     * @return Adapter
     */
    public function getDbAdapter()
    {
        return $this->dbAdapter;
    }

    /**
     * @param Adapter $dbAdapter
     * @return AbstractDbMapper
     */
    public function setDbAdapter(Adapter $dbAdapter)
    {
        $this->dbAdapter = $dbAdapter;
        if ($dbAdapter instanceof MasterSlaveAdapterInterface) {
            $this->setDbSlaveAdapter($dbAdapter->getSlaveAdapter());
        }
        return $this;
    }

    /**
     * @return Adapter
     */
    public function getDbSlaveAdapter()
    {
        return $this->dbSlaveAdapter ?: $this->dbAdapter;
    }

    /**
     * @param Adapter $dbAdapter
     * @return AbstractDbMapper
     */
    public function setDbSlaveAdapter(Adapter $dbSlaveAdapter)
    {
        $this->dbSlaveAdapter = $dbSlaveAdapter;
        return $this;
    }

    /**
     * @return ObservableStrategyInterface
     */
    public function getHydrator()
    {
        return $this->hydrator;
    }

    /**
     * @param ObservableStrategyInterface $hydrator
     * @return AbstractDbMapper
     */
    public function setHydrator(ObservableStrategyInterface $hydrator)
    {
        $this->hydrator = $hydrator;
        return $this;
    }

    /**
     * @return Sql
     */
    protected function getSql()
    {
        if (!$this->sql instanceof Sql) {
            $this->sql = new Sql($this->getDbAdapter());
        }

        return $this->sql;
    }

    /**
     * @param Sql
     * @return AbstractDbMapper
     */
    protected function setSql(Sql $sql)
    {
        $this->sql = $sql;
        return $this;
    }

    /**
     * @return Sql
     */
    protected function getSlaveSql()
    {
        if (!$this->slaveSql instanceof Sql) {
            $this->slaveSql = new Sql($this->getDbSlaveAdapter());
        }

        return $this->slaveSql;
    }

    /**
     * @param Sql
     * @return AbstractDbMapper
     */
    protected function setSlaveSql(Sql $sql)
    {
        $this->slaveSql = $sql;
        return $this;
    }

    /**
     * Uses the hydrator to convert the entity to an array.
     *
     * Use this method to ensure that you're working with an array.
     *
     * @param object $entity
     * @param ObservableStrategyInterface $hydrator
     * @param boolean $changesOnly
     * @param array $originalData
     *
     * @return array
     *
     * @throws Exception\InvalidArgumentException
     */
    public function entityToArray(
        AbstractDbEntity $entity,
        ObservableStrategyInterface $hydrator = null,
        $changesOnly = false,
        & $originalData = null
    ) {
        if (is_array($entity)) {
            return $entity; // cut down on duplicate code
        } elseif (is_object($entity)) {
            if (!$hydrator) {
                $hydrator = $this->getHydrator();
            }
            $originalData = $hydrator->extractOriginal($entity);
            if ($changesOnly) {
                $entityArray = $hydrator->extractChanges($entity);
            } else {
                $entityArray = $hydrator->extract($entity);
            }
            foreach ($this->serializedAttributeColumns as $column => $fields) {
                if (
                    array_key_exists($column, $entityArray) &&
                    !empty($entityArray[$column]) &&
                    !$this->isSerialized($entityArray[$column])
                ) {
                    throw new Exception\InvalidArgumentException(
                        'The data for column: ' . $column . ' must be serialized ' .
                        'prior to storing the entity into the database!'
                    );
                }
            }
            return $entityArray;
        }
        throw new Exception\InvalidArgumentException(
            'Entity passed to db mapper should be an array or object.'
        );
    }

    /**
     * Check if the given entity is empty, it is also possible to check if the
     * original data for this entity is empty.
     *
     * @param object  $entity
     *
     * @return boolean
     *
     * @throws Exception\InvalidArgumentException
     */
    public function isEntityEmpty(AbstractDbEntity $entity)
    {
        $prototype = $this->getEntityPrototype();
        if (!($entity instanceof $prototype)) {
            throw new Exception\InvalidArgumentException(
                'Only perform is entity ' . get_class($entity) .
                ' check on it\'s own mapper ' . get_class($prototype) . '!'
            );
        }
        return ($prototype == $entity);
    }

    /**
     * Enables the moderation logica
     *
     * @return void
     */
    public static function enableModerationMode()
    {
        self::$moderationMode = true;
    }

    /**
     * Disables the moderation logica
     *
     * @return void
     */
    public static function disableModerationMode()
    {
        self::$moderationMode = false;
    }

    /**
     * Validate if the entity belongs to this mapper
     *
     * @param AbstractDbEntity $entity
     * @return boolean
     * @throws Exception\UnexpectedValueException
     */
    protected function validateEntity(AbstractDbEntity $entity)
    {
        if (get_class($entity) !== get_class($this->getEntityPrototype())) {
            throw new Exception\UnexpectedValueException(
                'Dit not expect the given entity of type: ' .
                get_class($entity) . '. The type: ' .
                get_class($this->getEntityPrototype()) . ' should be given.'
            );
        }

        return true;
    }
}
