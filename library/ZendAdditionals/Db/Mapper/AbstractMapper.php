<?php

namespace ZendAdditionals\Db\Mapper;

use Zend\Db\Adapter\Adapter;
use Zend\Db\Adapter\Driver\ResultInterface;
use Zend\Db\Sql\Select;
use Zend\Db\Sql\Sql;
use Zend\Db\Sql\TableIdentifier;
use Zend\Stdlib\Hydrator\HydratorInterface;
use Zend\Stdlib\Hydrator\ClassMethods;
use ZendAdditionals\Stdlib\Hydrator\ObservableClassMethods;
use ZendAdditionals\Stdlib\Hydrator\Strategy\ObservableStrategyInterface;
use ZendAdditionals\Db\Adapter\MasterSlaveAdapterInterface;
use ZendAdditionals\Db\EntityAssociation\EntityAssociation;
use ZendAdditionals\Db\ResultSet\JoinedHydratingResultSet;
use Zend\Db\Adapter\AdapterAwareInterface;
use Zend\ServiceManager\ServiceManagerAwareInterface;
use Zend\ServiceManager\ServiceManager;

class AbstractMapper extends \Application\EventProvider implements
    ServiceManagerAwareInterface,
    AdapterAwareInterface
{

    const RELATION_TYPE_FOREIGN  = 'foreign';
    const RELATION_TYPE_MY       = 'my';
    const RELATION_TYPE_VALUE    = 'value';
    const RELATION_TYPE_CALLBACK = 'callback';
    const OPERAND_EQUALS         = 'eq';
    const OPERAND_NOT_EQUALS     = '!eq';
    const OPERAND_IN             = 'in';
    const OPERAND_NOT_IN         = '!in';
    const OPERAND_LESS           = 'le';
    const OPERAND_LESS_OR_EQUALS = 'lq';
    const OPERAND_MORE           = 'mo';
    const OPERAND_MORE_OR_EQUALS = 'mq';

    /**
     * @var Adapter
     */
    protected $dbAdapter;

    /**
     * @var Adapter
     */
    protected $dbSlaveAdapter;

    /**
     * @var ObservableClassMethods
     */
    protected $hydrator;

    /**
     * @var object
     */
    protected $entityPrototype;

    /**
     * @var Select
     */
    protected $selectPrototype;

    /**
     * @var Sql
     */
    private $sql;

    /**
     * @var Sql
     */
    private $slaveSql;

    /**
     * @var string
     */
    protected $tableName;

    /**
     * @var boolean
     */
    private $isInitialized = false;

    /**
     * array containing arrays of keys that are combined to primary keys
     * @var type
     */
    protected $primaries = array();

    /**
     * Identifier of a column that gets an auto generated value, only one is possible'
     *
     * @var string
     */
    protected $autoGenerated;

    /**
     * @var ServiceManager
     */
    protected $serviceManager;

    /**
     * @var array
     */
    protected $relations = array();

    /**
     * @var \SplObjectStorage
     */
    protected $entityAssociationStorage;

    /**
     * @param string $mapperServiceName
     * @param string $entityIdentifier
     *
     * @return array
     */
    public function getRelation($mapperServiceName, $entityIdentifier)
    {
        if (!isset($this->relations[$mapperServiceName][$entityIdentifier])) {
            throw new \UnexpectedValueException('Dit not expect the requested relation not to exist.');
        }

        return $this->relations[$mapperServiceName][$entityIdentifier];
    }

    /**
     * Performs some basic initialization setup and checks before running a query
     */
    protected function initialize()
    {
        if ($this->isInitialized) {
            return;
        }

        if (!$this->dbAdapter instanceof Adapter) {
            throw new \Exception('No db adapter present');
        }

        if (!$this->hydrator instanceof HydratorInterface) {
            $this->hydrator = new ClassMethods;
        }

        if (!is_object($this->entityPrototype)) {
            throw new \Exception('No entity prototype set');
        }

        $this->isInitialized = true;
    }

    /**
     * @param ServiceManager $serviceManager
     * @return AbstractMapper
     */
    public function setServiceManager(ServiceManager $serviceManager)
    {
        $this->serviceManager = $serviceManager;
        return $this;
    }

    /**
     * @return ServiceManager
     */
    public function getServiceManager()
    {
        return $this->serviceManager;
    }

    /**
     * Returns an array of column identifiers used for entities that are related
     *
     * @return array
     */
    public function getEntityAssociationColumns()
    {
        $return = array();

        foreach ($this->relations as $relation) {
            $return = array_merge($return, array_keys($relation));
        }

        return $return;
    }

    /**
     * @param string|null $table
     * return Select
     */
    protected function getSelect($table = null)
    {
        $table = $table ?: $this->tableName;
        $this->initialize();
        return $this->getSlaveSql()->select($table);
    }

    /**
     * @param Select $select
     * @return JoinedHydratingResultSet
     */
    protected function getResult(Select $select)
    {
        $this->initialize();
        $stmt = $this->getSlaveSql()->prepareStatementForSqlObject($select);
        $resultSet = new JoinedHydratingResultSet($this->getHydrator(), $this->getEntityPrototype());

        $associations = array_reverse($this->getEntityAssociationsForSelect($select), true);

        $resultSet->setAssociations($associations);

        echo $stmt->getSql();

        $resultSet->initialize($stmt->execute());

        $this->resetEntityAssociationStorage($select);

        return $resultSet;
    }

    protected function getCurrent(Select $select)
    {
        return $this->getResult($select)->current();
    }

    /**
     * Process the join conditions
     *
     * @param array $joinConditions
     * @param string $tableAlias
     *
     * @return string
     */
    protected function processJoinConditions(array $joinConditions, $tableAlias)
    {
        $return = '';
        foreach ($joinConditions as $condition) {
            $return .= (empty($return) ? '' : ' AND ') . $condition[0] . ' = ' . $tableAlias . '.' . $condition[1];
        }
        return $return;
    }

    /**
     * Add a join
     *
     * @param Select $select
     * @param string $entityIdentifier
     * @param EntityAssociation $parentAssociation
     *
     * @return EntityAssociation
     *
     * @throws \UnexpectedValueException
     */
    protected function addJoin(
        Select $select,
        $entityIdentifier,
        EntityAssociation $parentAssociation = null
    ) {
        $entityAssociation = null;

        $mapper = $this;
        if ($parentAssociation instanceof EntityAssociation) {
            $mapper = $parentAssociation->getMapper();
        }

        foreach ($mapper->relations as $mapperServiceName => $relations) {
            if (!isset($relations[$entityIdentifier])) {
                continue;
            }
            $entityAssociation = new EntityAssociation(
                $entityIdentifier,
                $mapper::SERVICE_NAME,
                $mapperServiceName
            );
            $entityAssociation->setServiceManager($this->getServiceManager());
            if ($parentAssociation instanceof EntityAssociation) {
                $entityAssociation->setParentAlias($parentAssociation->getAlias());
            }
            break;
        }
        if (!($entityAssociation instanceof EntityAssociation)) {
            throw new \UnexpectedValueException('did not expect this ehh');
        }

        $joinTableAlias = $this->getTableName();
        if ($parentAssociation instanceof EntityAssociation) {
            $joinTableAlias = $parentAssociation->getAlias();
            if (!$parentAssociation->getRequired()) {
                $entityAssociation->setRequired(false);
            }
        }
        /* @var $entityAssociation EntityAssociation */
        $joinConditions = $this->processJoinConditions($entityAssociation->getJoinCondition(), $joinTableAlias);

        $select->join(
            $entityAssociation->getjoinTable(),
            $joinConditions,
            $entityAssociation->getJoinColumns(),
            $entityAssociation->getJoinType()
        );

        $this->storeEntityAssociationToSelect($select, $entityAssociation);

        return $entityAssociation;
    }

    private function storeEntityAssociationToSelect(Select $select, EntityAssociation $entityAssociation)
    {
        if (!($this->entityAssociationStorage instanceof \SplObjectStorage)) {
            $this->entityAssociationStorage = new \SplObjectStorage();
        }
        if (!$this->entityAssociationStorage->contains($select)) {
            $this->entityAssociationStorage->attach($select, array());
        }
        $data = $this->entityAssociationStorage[$select];
        $data[$entityAssociation->getAlias()] = $entityAssociation;
        $this->entityAssociationStorage[$select] = $data;
    }

    private function getEntityAssociationsForSelect(Select $select)
    {
        if (
            !($this->entityAssociationStorage instanceof \SplObjectStorage) ||
            !$this->entityAssociationStorage->contains($select)
        ) {
            return;
        }
        return $this->entityAssociationStorage[$select];
    }

    private function resetEntityAssociationStorage(Select $select)
    {
        if (
            !($this->entityAssociationStorage instanceof \SplObjectStorage) ||
            !$this->entityAssociationStorage->contains($select)
        ) {
            return;
        }
        $this->entityAssociationStorage->detach($select);
    }

    /**
     * Save the given entity
     *
     * @param object $entity
     *
     * @return ResultInterface|bool Boolean true gets returned when there is nothing to update
     *
     * @throws \Exception
     */
    public function save($entity)
    {
        $this->initialize();

        if (get_class($entity) !== get_class($this->getEntityPrototype())) {
            throw new \UnexpectedValueException(
                'Dit not expect the given entity of type: ' . get_class($entity) .
                '. The type: ' . get_class($this->getEntityPrototype()) . ' should be given.'
            );
        }

        $hydrator = $this->getHydrator();

        $result = false;
        if ($hydrator->hasOriginal($entity) && !$this->isOriginalEmpty($entity, $hydrator)) {
            $result = $this->update($entity, null, $hydrator);
        } else {
            $result = $this->insert($entity, $hydrator);
        }

        return $result;
    }

    /**
     * @param object|array $entity
     * @param ObservableStrategyInterface|null $hydrator
     *
     * @return ResultInterface
     */
    protected function insert($entity, ObservableStrategyInterface $hydrator = null)
    {
        $this->initialize();
        $tableName = $this->getTableName();

        $sql = $this->getSql()->setTable($tableName);
        $insert = $sql->insert();

        if (!empty($this->autoGenerated)) {
            $autoGeneratedGet = 'get' . ucfirst($this->autoGenerated);
            if (null !== $entity->$autoGeneratedGet()) {
                throw new \Exception('Can not insert data that already has an auto generated value!');
            }
        }

        $rowData = $this->entityToArray($entity, $hydrator);

        // Put in better function
        $associatedColumns = $this->getEntityAssociationColumns();
        foreach ($associatedColumns as $associatedColumn) {
            if (array_key_exists($associatedColumn, $rowData)) {
                unset($rowData[$associatedColumn]);
            }
        }

        // If applicable remove auto generated column for insert
        if (!empty($this->autoGenerated)) {
            unset($rowData[$this->autoGenerated]);
        }

        $insert->values($rowData);

        $statement = $sql->prepareStatementForSqlObject($insert);

        /*@var $statement \Zend\Db\Adapter\Driver\Pdo\Statement*/
        $result = $statement->execute();
        /*@var $result \Zend\Db\Adapter\Driver\Pdo\Result*/

        if (
            null !== $this->autoGenerated &&
            null !== ($generatedValue = $result->getGeneratedValue())
        ) {
            $autoGeneratedSet = 'set' . ucfirst($this->autoGenerated);
            $entity->$autoGeneratedSet($generatedValue);
        }

        $hydrator->setChangesCommitted($entity);

        return $result;
    }

    /**
     * @param object|array $entity
     * @param string|array|closure $where
     * @param ObservableStrategyInterface|null $hydrator
     * @return ResultInterface
     */
    protected function update($entity, $where = null, ObservableStrategyInterface $hydrator = null)
    {
        $this->initialize();
        $tableName = $this->getTableName();

        $sql = $this->getSql()->setTable($tableName);
        $update = $sql->update();

        $originalData = array();

        $changedData = $this->entityToArray($entity, $hydrator, true, $originalData);


        // Put in better function
        $associatedColumns = $this->getEntityAssociationColumns();
        foreach ($associatedColumns as $associatedColumn) {
            if (array_key_exists($associatedColumn, $changedData)) {
                unset($changedData[$associatedColumn]);
            }
        }

        if (empty($changedData)) {
            return true;
        }

        if (empty($where)) {
            if ($this->isPrimaryKeyChanged($changedData)) {
                $previousPrimaryData = $this->getPrimaryData($originalData);
                if (empty($previousPrimaryData)) {
                    die('Can not update a non existing entity!');
                }
                $where = $previousPrimaryData;
            } else {
                $where = $this->getPrimaryData($this->entityToArray($entity, $hydrator));
            }
        }

        $update->set($changedData)
            ->where($where);

        $statement = $sql->prepareStatementForSqlObject($update);
        /*@var $statement \Zend\Db\Adapter\Driver\Pdo\Statement*/

        $result = $statement->execute();

        $hydrator->setChangesCommitted($entity);

        return $result;
    }

    /**
     * Check for a specific entity if the primary key has been changed
     *
     * @return boolean
     */
    protected function isPrimaryKeyChanged(array $changedData)
    {
        foreach ($this->primaries as $primary) {
            foreach ($primary as $key) {
                if (isset($changedData[$key])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Extract the primary data from an array of data extracted from the entity, this should be
     * the original data provided by reference when calling entityToArray
     *
     * @param array $data
     *
     * @return array
     */
    protected function getPrimaryData(array $data)
    {
        $return = array();
        foreach ($this->primaries as $primary) {
            foreach ($primary as $key) {
                if (isset($data[$key])) {
                    $return[$key] = $data[$key];
                }
            }
        }
        return $return;
    }

    /**
     * @param string|array|closure $where
     * @param string|TableIdentifier|null $tableName
     * @return ResultInterface
     */
    protected function delete($where, $tableName = null)
    {
        $tableName = $tableName ?: $this->getTableName();

        $sql = $this->getSql()->setTable($tableName);
        $delete = $sql->delete();

        $delete->where($where);

        $statement = $sql->prepareStatementForSqlObject($delete);

        return $statement->execute();
    }

    /**
     * @return string
     */
    public function getTableName()
    {
        return $this->tableName;
    }

    /**
     * @return object
     */
    public function getEntityPrototype()
    {
        return $this->entityPrototype;
    }

    /**
     * @param object $modelPrototype
     * @return AbstractDbMapper
     */
    public function setEntityPrototype($entityPrototype)
    {
        $this->entityPrototype = $entityPrototype;
        return $this;
    }

    /**
     * @return Adapter
     */
    public function getDbAdapter()
    {
        return $this->dbAdapter;
    }

    /**
     * @param Adapter $dbAdapter
     * @return AbstractDbMapper
     */
    public function setDbAdapter(Adapter $dbAdapter)
    {
        $this->dbAdapter = $dbAdapter;
        if ($dbAdapter instanceof MasterSlaveAdapterInterface) {
            $this->setDbSlaveAdapter($dbAdapter->getSlaveAdapter());
        }
        return $this;
    }

    /**
     * @return Adapter
     */
    public function getDbSlaveAdapter()
    {
        return $this->dbSlaveAdapter ?: $this->dbAdapter;
    }

    /**
     * @param Adapter $dbAdapter
     * @return AbstractDbMapper
     */
    public function setDbSlaveAdapter(Adapter $dbSlaveAdapter)
    {
        $this->dbSlaveAdapter = $dbSlaveAdapter;
        return $this;
    }

    /**
     * @return ObservableStrategyInterface
     */
    public function getHydrator()
    {
        return $this->hydrator;
    }

    /**
     * @param ObservableStrategyInterface $hydrator
     * @return AbstractDbMapper
     */
    public function setHydrator(ObservableStrategyInterface $hydrator)
    {
        if (!($hydrator instanceof ObservableStrategyInterface)) {
            throw new \InvalidArgumentException('Hydrator must implement ObservableStrategyInterface');
        }
        $this->hydrator = $hydrator;
        return $this;
    }

    /**
     * @return Sql
     */
    protected function getSql()
    {
        if (!$this->sql instanceof Sql) {
            $this->sql = new Sql($this->getDbAdapter());
        }

        return $this->sql;
    }

    /**
     * @param Sql
     * @return AbstractDbMapper
     */
    protected function setSql(Sql $sql)
    {
        $this->sql = $sql;
        return $this;
    }

    /**
     * @return Sql
     */
    protected function getSlaveSql()
    {
        if (!$this->slaveSql instanceof Sql) {
            $this->slaveSql = new Sql($this->getDbSlaveAdapter());
        }

        return $this->slaveSql;
    }

    /**
     * @param Sql
     * @return AbstractDbMapper
     */
    protected function setSlaveSql(Sql $sql)
    {
        $this->slaveSql = $sql;
        return $this;
    }

    /**
     * Uses the hydrator to convert the entity to an array.
     *
     * Use this method to ensure that you're working with an array.
     *
     * @param object $entity
     * @param ObservableStrategyInterface $hydrator
     * @param boolean $changesOnly
     * @param array $originalData
     *
     * @return array
     *
     * @throws Exception\InvalidArgumentException
     */
    public function entityToArray(
        $entity,
        ObservableStrategyInterface $hydrator = null,
        $changesOnly = false,
        & $originalData = null
    ) {
        if (is_array($entity)) {
            return $entity; // cut down on duplicate code
        } elseif (is_object($entity)) {
            if (!$hydrator) {
                $hydrator = $this->getHydrator();
            }
            $originalData = $hydrator->extractOriginal($entity);
            if ($changesOnly) {
                $entityArray = $hydrator->extractChanges($entity);
            } else {
                $entityArray = $hydrator->extract($entity);
            }
            return $entityArray;
        }
        throw new Exception\InvalidArgumentException('Entity passed to db mapper should be an array or object.');
    }

    /**
     *
     * @param type $entity
     * @param \ZendAdditionals\Stdlib\Hydrator\ObservableClassMethods $hydrator
     * @return boolean
     */
    protected function isOriginalEmpty($entity, ObservableClassMethods $hydrator)
    {
        $rowData = $hydrator->extractOriginal($entity);
        $isEmpty = true;

        foreach($rowData as $data) {
            if ($data !== NULL) {
                $isEmpty = false;
                break;
            }
        }

        return $isEmpty;
    }
}

